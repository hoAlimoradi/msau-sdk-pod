// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.9.2 (swiftlang-5.9.2.2.56 clang-1500.1.0.2.5)
// swift-module-flags: -target arm64-apple-ios12.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Onone -module-name cryptography
// swift-module-flags-ignorable: -enable-bare-slash-regex
import AVFoundation
import AVKit
import CommonCrypto
import CoreData
import CoreLocation
import Darwin
import DeveloperToolsSupport
import Foundation
import MapKit
import MessageUI
import MobileCoreServices
import Network
import ObjectiveC
import PDFKit
import QuartzCore
import Security
import Swift
import SwiftUI
import UIKit.UIApplication
import UIKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
@_exported import cryptography
import ObjectiveC.runtime
import zlib
public enum CCError : cryptography.CC.CCCryptorStatus, Swift.Error {
  case paramError
  case bufferTooSmall
  case memoryFailure
  case alignmentError
  case decodeError
  case unimplemented
  case overflow
  case rngFailure
  case unspecifiedError
  case callSequenceError
  case keySizeError
  case invalidKey
  public static var debugLevel: Swift.Int
  public init?(rawValue: cryptography.CC.CCCryptorStatus)
  public typealias RawValue = cryptography.CC.CCCryptorStatus
  public var rawValue: cryptography.CC.CCCryptorStatus {
    get
  }
}
@_hasMissingDesignatedInitializers open class PKCS8PublicKey {
  public static func addHeader(_ derKey: Foundation.Data) -> Foundation.Data
  public static func getPKCS1DEROffset(_ derKey: Foundation.Data) -> Swift.Int?
  public static func stripHeaderIfAny(_ derKey: Foundation.Data) -> Foundation.Data?
  public static func hasCorrectHeader(_ derKey: Foundation.Data) -> Swift.Bool
  @objc deinit
}
public struct InitializeStatusResult {
  public var id: Swift.String
  public var message: Swift.String
}
public enum ConnectionEvent {
  case connected([Swift.String : Swift.String])
  case disconnected(Swift.String, Swift.UInt16)
  case text(Swift.String)
  case binary(Foundation.Data)
  case pong(Foundation.Data?)
  case ping(Foundation.Data?)
  case error(any Swift.Error)
}
public protocol Connection {
  func write(data: Foundation.Data, opcode: cryptography.FrameOpCode)
}
public protocol ConnectionDelegate : AnyObject {
  func didReceive(event: cryptography.ServerEvent)
}
public enum ServerEvent {
  case connected(any cryptography.Connection, [Swift.String : Swift.String])
  case disconnected(any cryptography.Connection, Swift.String, Swift.UInt16)
  case text(any cryptography.Connection, Swift.String)
  case binary(any cryptography.Connection, Foundation.Data)
  case pong(any cryptography.Connection, Foundation.Data?)
  case ping(any cryptography.Connection, Foundation.Data?)
}
public protocol Server {
  func start(address: Swift.String, port: Swift.UInt16) -> (any Swift.Error)?
}
@_hasMissingDesignatedInitializers public class Log {
  public static func print(_ items: Swift.String..., filename: Swift.String = #file, function: Swift.String = #function, line: Swift.Int = #line, separator: Swift.String = " ", terminator: Swift.String = "\n")
  public static func print(_ items: Any..., separator: Swift.String = " ", terminator: Swift.String = "\n")
  @objc deinit
}
public protocol MsauIssueCertResultProtocol {
  func observerIssueCertResult(issueCertResult: cryptography.IssueCertResultModel)
}
public enum HTTPUpgradeError : Swift.Error {
  case notAnUpgrade(Swift.Int, [Swift.String : Swift.String])
  case invalidData
}
public struct HTTPWSHeader {
  public static func createUpgrade(request: Foundation.URLRequest, supportsCompression: Swift.Bool, secKeyValue: Swift.String) -> Foundation.URLRequest
  public static func generateWebSocketKey() -> Swift.String
}
public enum HTTPEvent {
  case success([Swift.String : Swift.String])
  case failure(any Swift.Error)
}
public protocol HTTPHandlerDelegate : AnyObject {
  func didReceiveHTTP(event: cryptography.HTTPEvent)
}
public protocol HTTPHandler {
  func register(delegate: any cryptography.HTTPHandlerDelegate)
  func convert(request: Foundation.URLRequest) -> Foundation.Data
  func parse(data: Foundation.Data) -> Swift.Int
}
public protocol HTTPServerDelegate : AnyObject {
  func didReceive(event: cryptography.HTTPEvent)
}
public protocol HTTPServerHandler {
  func register(delegate: any cryptography.HTTPServerDelegate)
  func parse(data: Foundation.Data)
  func createResponse(headers: [Swift.String : Swift.String]) -> Foundation.Data
}
public struct URLParts {
}
extension Foundation.URL {
  public var isTLSScheme: Swift.Bool {
    get
  }
  public func getParts() -> cryptography.URLParts?
}
@_hasMissingDesignatedInitializers public class MSAU {
  public static let ekycResultObserverKey: Swift.String
  public static let ekycResultObserverIdentifier: Swift.String
  public static var uiKitConfigMSAU: cryptography.MSSUIKitConfig
  public static func getInstance() -> cryptography.MSAU
  public typealias ThrowableCallback = () throws -> Swift.String
  public func initializeCrashReporter()
  public func initializeNetworkLoggerViewController()
  public func initialize(window: UIKit.UIWindow, config: cryptography.MSSUIKitConfig, retryCount: Swift.Int = 3, completion: @escaping (Swift.Result<cryptography.InitializeStatusResult, any Swift.Error>) -> Swift.Void)
  public func setDefaultNationalCode(_ nationalNumber: Swift.String)
  public func setDefaultPhoneNumber(_ phoneNumber: Swift.String)
  public func setPaymentUrlSchema(url: Foundation.URL?)
  public func setSocketMessage(content: Swift.String)
  public func showMSAUUI(host: UIKit.UIViewController) throws
  public func getChallengeBase64(_ msisdn: Swift.String) -> Swift.String?
  public func showRegistrationBySignedMsisdn(host: UIKit.UIViewController, registerType: cryptography.RegisterType, msisdn: Swift.String, signedChallengeBase64: Swift.String) throws
  public func showRegistrationByOTP(host: UIKit.UIViewController) throws
  public func showIssueCert(host: UIKit.UIViewController, userInfo: cryptography.UserInfo?) throws
  public func showLoginErorrDialog(message: Swift.String)
  public func showChangePassword(host: UIKit.UIViewController) throws
  public func getUUID() -> Swift.String?
  public func isUserLogin() -> Swift.Bool
  public func isUserRegistered() -> Swift.Bool
  public func getMSAUInitializeStatus() -> cryptography.InitializeStatus
  public func getCertificatesKeyInformation(callback: @escaping (cryptography.CertificateUserKeyInformation) -> Swift.Void)
  public func validateCert(keyId: Swift.Int, certificateBase64: Swift.String?, issuerCertBase64: Swift.String?, callback: @escaping (cryptography.CertificateStatus) -> Swift.Void)
  public enum CustomError : Swift.Error, Swift.Equatable {
    case NOT_INITIALIZED_SDK
    case CONFIGURATION_JSON_FILE_NOT_FOUND
    case CONFIGURATION_JSON_FILE_NOT_VALID
    case CONFIGURATION_NOT_AVAILABLE
    case PHONE_NUM_NOT_VALID
    case NATIONAL_ID_NOT_VALID
    case USER_NOT_REGISTERED
    case USER_NOT_AUTHENTICATED
    case USER_REGISTERED_PREVIOUSLY
    case DEPRECATED_SDK_VERSION
    case unexpected(code: Swift.Int)
    public var description: Swift.String {
      get
    }
    public var customDescription: Swift.String {
      get
    }
    public static func == (a: cryptography.MSAU.CustomError, b: cryptography.MSAU.CustomError) -> Swift.Bool
  }
  @objc deinit
}
extension cryptography.MSAU : cryptography.WebSocketDelegate {
  public func didReceive(event: cryptography.WebSocketEvent, client: any cryptography.WebSocketClient)
}
public protocol CryptoSwiftCryptor {
  mutating func seek(to: Swift.Int) throws
}
public protocol CryptoSwiftCryptors : AnyObject {
  func makeEncryptor() throws -> any cryptography.CryptoSwiftCryptor & cryptography.CryptoSwiftUpdatable
  func makeDecryptor() throws -> any cryptography.CryptoSwiftCryptor & cryptography.CryptoSwiftUpdatable
  static func randomIV(_ blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
}
extension cryptography.CryptoSwiftCryptors {
  public static func randomIV(_ count: Swift.Int) -> Swift.Array<Swift.UInt8>
  public static func zeroIV(_ count: Swift.Int) -> Swift.Array<Swift.UInt8>
}
public enum TransactionResultStatus : Swift.String, Swift.Codable {
  case success
  case failure
  case userCanceled
  case unknown
  public var toCapsLock: Swift.String {
    get
  }
  public var value: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers open class EC {
  public static func generateKeyPair(_ keySize: Swift.Int) throws -> (Foundation.Data, Foundation.Data)
  public static func getPublicKeyFromPrivateKey(_ privateKey: Foundation.Data) throws -> Foundation.Data
  public static func signHash(_ privateKey: Foundation.Data, hash: Foundation.Data) throws -> Foundation.Data
  public static func verifyHash(_ publicKey: Foundation.Data, hash: Foundation.Data, signedData: Foundation.Data) throws -> Swift.Bool
  public static func computeSharedSecret(_ privateKey: Foundation.Data, publicKey: Foundation.Data) throws -> Foundation.Data
  public struct KeyComponents {
    public init(_ keySize: Swift.Int, _ x: Foundation.Data, _ y: Foundation.Data, _ d: Foundation.Data)
    public var keySize: Swift.Int
    public var x: Foundation.Data
    public var y: Foundation.Data
    public var d: Foundation.Data
  }
  public static func getPublicKeyComponents(_ keyData: Foundation.Data) throws -> cryptography.EC.KeyComponents
  public static func getPrivateKeyComponents(_ keyData: Foundation.Data) throws -> cryptography.EC.KeyComponents
  public static func createFromData(_ keySize: Darwin.size_t, _ x: Foundation.Data, _ y: Foundation.Data) throws -> Foundation.Data
  public static func available() -> Swift.Bool
  @objc deinit
}
public enum HTTPStatusCodeHovita : Swift.Int {
  case notParsJson
  case unknown
  case phoneNumberNotFound
  case ekycUplaodVideoNotFountFile
  case ekycUplaodVideoNotFountFetTransactionId
  case FcmTokenNotFound
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public protocol MsauSocketMessageProtocol {
  func getSocketMessage(socketMessage: Swift.String)
}
public enum BlockMode : cryptography.CC.CCMode {
  case ecb, cbc, cfb, ctr, f8, lrw, ofb, xts, rc4, cfb8
  public init?(rawValue: cryptography.CC.CCMode)
  public typealias RawValue = cryptography.CC.CCMode
  public var rawValue: cryptography.CC.CCMode {
    get
  }
}
public struct CryptoSwiftCTR {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: cryptography.CryptoSwiftCTR.Error, b: cryptography.CryptoSwiftCTR.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: cryptography.CryptoSwiftBlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>, counter: Swift.Int = 0)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping cryptography.CipherOperationOnBlock, encryptionOperation: @escaping cryptography.CipherOperationOnBlock) throws -> any cryptography.CryptoSwiftCipherModeWorker
}
@_hasMissingDesignatedInitializers public class X509PublicKey {
  public var algOid: Swift.String? {
    get
  }
  public var algName: Swift.String? {
    get
  }
  public var algParams: Swift.String? {
    get
  }
  public var derEncodedKey: Foundation.Data? {
    get
  }
  public var key: Foundation.Data? {
    get
  }
  @objc deinit
}
public struct MSSUIKitConfig {
  public static let fontName: Swift.String
  public var pageBackgroundResId: UIKit.UIColor
  public var errorColorResId: UIKit.UIColor
  public var warningColorResId: UIKit.UIColor
  public var datePickerFont: UIKit.UIFont
  public var datePickerButtonFont: UIKit.UIFont
  public var tabBarFont: UIKit.UIFont
  public var otpFont: UIKit.UIFont
  public var buttonCornerRadiusDimenResId: CoreFoundation.CGFloat
  public var buttonBorderWidthDimenResId: CoreFoundation.CGFloat
  public var buttonBackgroundColorResId: UIKit.UIColor
  public var buttonBackgroundColorSecondlyResId: UIKit.UIColor
  public var buttonTextColorResId: UIKit.UIColor
  public var buttonBorderColorResId: UIKit.UIColor
  public var buttonFont: UIKit.UIFont
  public var buttonDisableBackgroundColorResId: UIKit.UIColor
  public var buttonDisableTextColorResId: UIKit.UIColor
  public var buttonDisableBorderColorResId: UIKit.UIColor
  public var backButtonBackgroundColorResId: UIKit.UIColor
  public var backButtonBorderColorResId: UIKit.UIColor
  public var backButtonCornerRadiusDimenResId: CoreFoundation.CGFloat
  public var backButtonBorderWidthDimenResId: CoreFoundation.CGFloat
  public var backButtonTextColorResId: UIKit.UIColor
  public var backButtonFont: UIKit.UIFont
  public var titleTextColorResId: UIKit.UIColor
  public var titleTextViewFont: UIKit.UIFont
  public var subTitleTextColor: UIKit.UIColor
  public var subTitleTextViewFont: UIKit.UIFont
  public var nameTextViewFontInCertList: UIKit.UIFont
  public var termConditionFont: UIKit.UIFont
  public var termConditionLinkFont: UIKit.UIFont
  public var nameTextColorInCertDetialResId: UIKit.UIColor
  public var valueTextColorInCertDetialResId: UIKit.UIColor
  public var editTextCornerRadiusDimenResId: CoreFoundation.CGFloat
  public var editTextBorderWidthDimenResId: CoreFoundation.CGFloat
  public var editTextBackgroundColorResId: UIKit.UIColor
  public var editTextFilledBorderColorResId: UIKit.UIColor
  public var editTextEmptyBorderColorResId: UIKit.UIColor
  public var editTextColorInputValidFilled: UIKit.UIColor
  public var editTextColorInputInValid: UIKit.UIColor
  public var editTextCursorColor: UIKit.UIColor
  public var editTextPlaceholderColorResId: UIKit.UIColor
  public var editTextFont: UIKit.UIFont
  public var logoDrawableResId: UIKit.UIImage?
  public var phoneNumberEditIconDrawableResId: UIKit.UIImage?
  public var infoSquareIconDrawableResId: UIKit.UIImage?
  public var phoneGrayIconDrawableResId: UIKit.UIImage?
  public var raIconDrawableResId: UIKit.UIImage?
  public var locationIconDrawableResId: UIKit.UIImage?
  public var lockGrayIconDrawableResId: UIKit.UIImage?
  public var lockYellowIconDrawableResId: UIKit.UIImage?
  public var checkBoxTickIconDrawableResId: UIKit.UIImage?
  public var virtualIssueCertDrawableResId: UIKit.UIImage?
  public var inBranchIssueCertDrawableResId: UIKit.UIImage?
  public var issueSuccessCertDrawableResId: UIKit.UIImage?
  public var exitDrawableResId: UIKit.UIImage?
  public var checkStatusFillDrawableResId: UIKit.UIImage?
  public var statusDualRingDrawableResId: UIKit.UIImage?
  public var todoStateDrawableResId: UIKit.UIImage?
  public var profileDrawableResId: UIKit.UIImage?
  public var calendarDrawableResId: UIKit.UIImage?
  public var moreSquareDrawableResId: UIKit.UIImage?
  public var paperDrawableResId: UIKit.UIImage?
  public var titleTextInDashboardToolbar: Swift.String?
  public var subTitleTextInDashboardToolbar: Swift.String?
  public var backInToolbarIconDrawableResId: UIKit.UIImage?
  public var openLockInToolbarIconDrawableResId: UIKit.UIImage?
  public var titleTextInToolbarColorResId: UIKit.UIColor
  public var errorIconInErrorViewAlertDrawableResId: UIKit.UIImage?
  public var emptyTableIconDrawableResId: UIKit.UIImage?
  public var refreshIconDrawableResId: UIKit.UIImage?
  public var discountIconDrawableResId: UIKit.UIImage?
  public var keyShapeIconDrawableResId: UIKit.UIImage?
  public var faceIdIconDrawableResId: UIKit.UIImage?
  public var minesShapeIconDrawableResId: UIKit.UIImage?
  public var scriptSignatureIconDrawableResId: UIKit.UIImage?
  public var deleteAccountIconDrawableResId: UIKit.UIImage?
  public var deleteAccountPopUpIconDrawableResId: UIKit.UIImage?
  public var profileTabSelectedIconDrawableResId: UIKit.UIImage?
  public var profileTabUnSelectedIconDrawableResId: UIKit.UIImage?
  public var categoryTabIconDrawableResId: UIKit.UIImage?
  public var certsTabIconDrawableResId: UIKit.UIImage?
  public var itemRectangleIconDrawableResId: UIKit.UIImage?
  public var itemRectangleBigIconDrawableResId: UIKit.UIImage?
  public var profileUserIconDrawableResId: UIKit.UIImage?
  public var certsDashboardIconDrawableResId: UIKit.UIImage?
  public var settingDashboardIconDrawableResId: UIKit.UIImage?
  public var transactionHistoryDashboardIconDrawableResId: UIKit.UIImage?
  public var issueCertDashboardIconDrawableResId: UIKit.UIImage?
  public var checkBoxGreenEmptyIconDrawableResId: UIKit.UIImage?
  public var checkBoxGreenIconDrawableResId: UIKit.UIImage?
  public var nextIconDrawableResId: UIKit.UIImage?
  public var previousIconDrawableResId: UIKit.UIImage?
  public var warningIconDrawableResId: UIKit.UIImage?
  public var pdfDownloadIconDrawableResId: UIKit.UIImage?
  public var archiveNextTimeIconDrawableResId: UIKit.UIImage?
  public var phoneCallIconDrawableResId: UIKit.UIImage?
  public var excludeIconDrawableResId: UIKit.UIImage?
  public var keyAlgorithmIconDrawableResId: UIKit.UIImage?
  public var keyIdCertIconDrawableResId: UIKit.UIImage?
  public var keyCalendarIconDrawableResId: UIKit.UIImage?
  public var keyIssuerCertIconDrawableResId: UIKit.UIImage?
  public var keyScanCertIconDrawableResId: UIKit.UIImage?
  public var keyCertProfileIconDrawableResId: UIKit.UIImage?
  public var circleButtonIconDrawableResId: UIKit.UIImage?
  public var circleFilledIconDrawableResId: UIKit.UIImage?
  public var fullScreenIconDrawableResId: UIKit.UIImage?
  public var fullScreenCloseIconDrawableResId: UIKit.UIImage?
  public var closeIconDrawableResId: UIKit.UIImage?
  public var downArrowIconDrawableResId: UIKit.UIImage?
  public var resizeIconDrawableResId: UIKit.UIImage?
  public var transactionImportCertIconDrawableResId: UIKit.UIImage?
  public var transactionKeyGenerationIconDrawableResId: UIKit.UIImage?
  public var transactionSignIconDrawableResId: UIKit.UIImage?
  public var transactionIdIconDrawableResId: UIKit.UIImage?
  public var onlinePaymentWithCreditCardIconDrawableResId: UIKit.UIImage?
  public var paymentAmountStackTrailingIconDrawableResId: UIKit.UIImage?
  public var paymentLeftIconDrawableResId: UIKit.UIImage?
  public var paymentRightIconDrawableResId: UIKit.UIImage?
  public var eyeDisableIconDrawableResId: UIKit.UIImage?
  public var eyeIconDrawableResId: UIKit.UIImage?
  public var registrationBySignedMsisdnTypeView: cryptography.RegistrationBySignedMsisdnTypeView
  public var popUpTypeView: cryptography.PopUpTypeView
  public var popUpTitleTextColorResId: UIKit.UIColor
  public var popUpTitleTextViewFont: UIKit.UIFont
  public var popUpDisplayMessageTextColorResId: UIKit.UIColor
  public var popUpDisplayMessageTextViewFont: UIKit.UIFont
  public var popUpDisplayMessageCounterTextViewFont: UIKit.UIFont
  public var userCanDrawingSignImage: Swift.Bool
  public var defaultPhoneNumber: Swift.String?
  public var defaultNationalCode: Swift.String?
  public var userCanLogoutFromSdk: Swift.Bool
  public var paymentDetailsVisibility: Swift.Bool
  public var paymentDiscountCodeVisibility: Swift.Bool
  public var msauEkycProviderProtocol: (any cryptography.MsauEkycProviderProtocol)?
  public var msauIssueCertResultProtocol: (any cryptography.MsauIssueCertResultProtocol)?
  public var msauSocketMessageProtocol: (any cryptography.MsauSocketMessageProtocol)?
  public var showSplash: Swift.Bool
  public var indicatorType: cryptography.LaodingIndicatorType
  public var sdkIsMainApplication: Swift.Bool
  public var selectedLanguage: cryptography.MsauLanguagesEnum
  public func returnKernel(_ named: Swift.String) -> Swift.String?
}
extension cryptography.ChaCha20 {
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
@usableFromInline
final internal class CryptoSwiftBlockEncryptor : cryptography.CryptoSwiftCryptor, cryptography.CryptoSwiftUpdatable {
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: cryptography.CryptoSwiftPadding, _ worker: any cryptography.CryptoSwiftCipherModeWorker) throws
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8>
  @usableFromInline
  final internal func seek(to: Swift.Int) throws
  @objc @usableFromInline
  deinit
}
extension UIKit.UIFont {
  public static let loadAllFonts: ()
}
extension UIKit.UIFont {
  public static func registerCustomFontsIfNeeded()
}
public enum IssueCertStepResultModel : Swift.String {
  case payment
  case initial
  case keyGenerated
  case csrSigned
  case certCreated
  case certImported
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol _UInt8TypeCryptoSwift {
}
extension Swift.UInt8 : cryptography._UInt8TypeCryptoSwift {
}
extension Swift.UInt8 {
  public func bits() -> [cryptography.CryptoSwiftBit]
  public func bits() -> Swift.String
}
@_hasMissingDesignatedInitializers open class CCM {
  public static func crypt(_ opMode: cryptography.OpMode, algorithm: cryptography.Algorithm, data: Foundation.Data, key: Foundation.Data, iv: Foundation.Data, aData: Foundation.Data, tagLength: Swift.Int) throws -> (Foundation.Data, Foundation.Data)
  public static func available() -> Swift.Bool
  @objc deinit
}
public class RaPartEkycProvider : cryptography.BaseRaEkycProvider {
  public init()
  @objc deinit
}
public class RaHoshyarEkycProvider : cryptography.BaseRaEkycProvider {
  public init()
  @objc deinit
}
final public class SimpleASN1Reader : cryptography.SimpleASN1Reading {
  public init(_ encoding: [Swift.UInt8])
  final public func getReaderForContents() throws -> any cryptography.SimpleASN1Reading
  final public func getReaderForContents(identifiedBy expectedIdentifier: Swift.UInt8) throws -> any cryptography.SimpleASN1Reading
  final public func readContents() throws -> [Swift.UInt8]
  final public func readContents(identifiedBy expectedIdentifier: Swift.UInt8) throws -> [Swift.UInt8]
  final public func readContentsOfBitString() throws -> [Swift.UInt8]
  final public func skipComponent() throws
  final public func skipComponent(identifiedBy expectedIdentifier: Swift.UInt8) throws
  final public func skip(_ expectedBytes: [Swift.UInt8]) throws
  final public func unwrap() throws
  final public func unwrap(expectedIdentifier: Swift.UInt8) throws
  final public func peek() throws -> Swift.UInt8
  @objc deinit
}
public enum FoundationTransportError : Swift.Error {
  case invalidRequest
  case invalidOutputStream
  case timeout
  public static func == (a: cryptography.FoundationTransportError, b: cryptography.FoundationTransportError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc public class FoundationTransport : ObjectiveC.NSObject, cryptography.Transport, Foundation.StreamDelegate {
  public var usingTLS: Swift.Bool {
    get
  }
  public init(streamConfiguration: ((Foundation.InputStream, Foundation.OutputStream) -> Swift.Void)? = nil)
  @objc deinit
  public func connect(url: Foundation.URL, timeout: Swift.Double = 10, certificatePinning: (any cryptography.CertificatePinning)? = nil)
  public func disconnect()
  public func register(delegate: any cryptography.TransportEventClient)
  public func write(data: Foundation.Data, completion: @escaping (((any Swift.Error)?) -> ()))
  @objc open func stream(_ aStream: Foundation.Stream, handle eventCode: Foundation.Stream.Event)
}
extension cryptography.CryptoSwiftPKCS5 {
  public struct CryptoSwiftPBKDF1 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: cryptography.CryptoSwiftPKCS5.CryptoSwiftPBKDF1.Error, b: cryptography.CryptoSwiftPKCS5.CryptoSwiftPBKDF1.Error) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum Variant {
      case md5, sha1
      @usableFromInline
      internal var size: Swift.Int {
        get
      }
      @usableFromInline
      internal func calculateHash(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
      public static func == (a: cryptography.CryptoSwiftPKCS5.CryptoSwiftPBKDF1.Variant, b: cryptography.CryptoSwiftPKCS5.CryptoSwiftPBKDF1.Variant) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    @usableFromInline
    internal let iterations: Swift.Int
    @usableFromInline
    internal let variant: cryptography.CryptoSwiftPKCS5.CryptoSwiftPBKDF1.Variant
    @usableFromInline
    internal let keyLength: Swift.Int
    @usableFromInline
    internal let t1: Swift.Array<Swift.UInt8>
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, variant: cryptography.CryptoSwiftPKCS5.CryptoSwiftPBKDF1.Variant = .sha1, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil) throws
    @inlinable public func calculate() -> Swift.Array<Swift.UInt8> {
      var t = self.t1
      for _ in 2...self.iterations {
        t = self.variant.calculateHash(t)
      }
      return Array(t[0..<self.keyLength])
    }
  }
}
@_hasMissingDesignatedInitializers open class KeyStoreEditor {
  public static func upsertKey(_ pemKey: Swift.String, keyTag: Swift.String, options: [Foundation.NSString : Swift.AnyObject] = [:]) throws
  public static func getKey(_ keyTag: Swift.String) throws -> Foundation.Data
  public static func delKey(_ keyTag: Swift.String) throws
  @objc deinit
}
extension Swift.String {
  public func isValidIranianNationallCode() -> Swift.Bool
  public var replacedArabicDigitsWithEnglish: Swift.String {
    get
  }
}
extension Swift.Collection where Self.Element == Swift.UInt8, Self.Index == Swift.Int {
  @inlinable internal func toUInt32Array() -> Swift.Array<Swift.UInt32> {
    guard !isEmpty else {
      return []
    }

    let c = strideCount(from: startIndex, to: endIndex, by: 4)
    return Array<UInt32>(unsafeUninitializedCapacity: c) { buf, count in
      var counter = 0
      for idx in stride(from: startIndex, to: endIndex, by: 4) {
        let val = UInt32(bytes: self, fromIndex: idx).bigEndian
        buf[counter] = val
        counter += 1
      }
      count = counter
      assert(counter == c)
    }
  }
  @inlinable internal func toUInt64Array() -> Swift.Array<Swift.UInt64> {
    guard !isEmpty else {
      return []
    }

    let c = strideCount(from: startIndex, to: endIndex, by: 8)
    return Array<UInt64>(unsafeUninitializedCapacity: c) { buf, count in
      var counter = 0
      for idx in stride(from: startIndex, to: endIndex, by: 8) {
        let val = UInt64(bytes: self, fromIndex: idx).bigEndian
        buf[counter] = val
        counter += 1
      }
      count = counter
      assert(counter == c)
    }
  }
}
@usableFromInline
internal func strideCount(from: Swift.Int, to: Swift.Int, by: Swift.Int) -> Swift.Int
final public class CryptoSwiftSHA2 {
  @usableFromInline
  final internal let variant: cryptography.CryptoSwiftSHA2.Variant
  @usableFromInline
  final internal let size: Swift.Int
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal let digestLength: Swift.Int
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var processedBytesTotalCount: Swift.Int
  @usableFromInline
  final internal var accumulatedHash32: [Swift.UInt32]
  @usableFromInline
  final internal var accumulatedHash64: [Swift.UInt64]
  @frozen public enum Variant : Swift.RawRepresentable {
    case sha224, sha256, sha384, sha512
    public var digestLength: Swift.Int {
      get
    }
    public var blockSize: Swift.Int {
      get
    }
    public typealias RawValue = Swift.Int
    public var rawValue: cryptography.CryptoSwiftSHA2.Variant.RawValue {
      get
    }
    public init?(rawValue: cryptography.CryptoSwiftSHA2.Variant.RawValue)
    @usableFromInline
    internal var h: Swift.Array<Swift.UInt64> {
      get
    }
    @usableFromInline
    internal var finalLength: Swift.Int {
      get
    }
  }
  public init(variant: cryptography.CryptoSwiftSHA2.Variant)
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  @usableFromInline
  final internal func process64(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.Array<Swift.UInt64>)
  @usableFromInline
  final internal func process32(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.Array<Swift.UInt32>)
  @objc deinit
}
extension cryptography.CryptoSwiftSHA2 : cryptography.CryptoSwiftUpdatable {
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      let lengthInBits = (processedBytesTotalCount + self.accumulated.count) * 8
      let lengthBytes = lengthInBits.bytes(totalBytes: self.blockSize / 8) // A 64-bit/128-bit representation of b. blockSize fit by accident.

      // Step 1. Append padding
      bitPadding(to: &self.accumulated, blockSize: self.blockSize, allowance: self.blockSize / 8)

      // Step 2. Append Length a 64-bit representation of lengthInBits
      self.accumulated += lengthBytes
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: self.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= self.blockSize {
        switch self.variant {
          case .sha224, .sha256:
            self.process32(block: chunk, currentHash: &self.accumulatedHash32)
          case .sha384, .sha512:
            self.process64(block: chunk, currentHash: &self.accumulatedHash64)
          }
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)
    self.processedBytesTotalCount += processedBytes

    // output current hash
    var result = Array<UInt8>(repeating: 0, count: variant.digestLength)
    switch self.variant {
      case .sha224, .sha256:
        var pos = 0
        for idx in 0..<self.accumulatedHash32.count where idx < self.variant.finalLength {
          let h = accumulatedHash32[idx]
          result[pos + 0] = UInt8((h >> 24) & 0xff)
          result[pos + 1] = UInt8((h >> 16) & 0xff)
          result[pos + 2] = UInt8((h >> 8) & 0xff)
          result[pos + 3] = UInt8(h & 0xff)
          pos += 4
        }
      case .sha384, .sha512:
        var pos = 0
        for idx in 0..<self.accumulatedHash64.count where idx < self.variant.finalLength {
          let h = accumulatedHash64[idx]
          result[pos + 0] = UInt8((h >> 56) & 0xff)
          result[pos + 1] = UInt8((h >> 48) & 0xff)
          result[pos + 2] = UInt8((h >> 40) & 0xff)
          result[pos + 3] = UInt8((h >> 32) & 0xff)
          result[pos + 4] = UInt8((h >> 24) & 0xff)
          result[pos + 5] = UInt8((h >> 16) & 0xff)
          result[pos + 6] = UInt8((h >> 8) & 0xff)
          result[pos + 7] = UInt8(h & 0xff)
          pos += 8
        }
    }

    // reset hash value for instance
    if isLast {
      switch self.variant {
        case .sha224, .sha256:
          self.accumulatedHash32 = self.variant.h.lazy.map { UInt32($0) } // FIXME: UInt64 for process64
        case .sha384, .sha512:
          self.accumulatedHash64 = self.variant.h
      }
    }

    return result
  }
}
final public class Checksum {
  @usableFromInline
  internal static let table32: [Swift.UInt32]
  @usableFromInline
  internal static let table32c: [Swift.UInt32]
  @usableFromInline
  internal static let table16: [Swift.UInt16]
  @usableFromInline
  internal init()
  @inlinable final internal func crc32(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    var crc: UInt32 = seed != nil ? seed! : 0xFFFF_FFFF
    for chunk in message.batched(by: 256) {
      for b in chunk {
        let idx = Int((crc ^ UInt32(reflect ? b : reversed(b))) & 0xFF)
        crc = (crc >> 8) ^ Checksum.table32[idx]
      }
    }
    return (reflect ? crc : reversed(crc)) ^ 0xFFFF_FFFF
  }
  @inlinable final internal func crc32c(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    var crc: UInt32 = seed != nil ? seed! : 0xFFFF_FFFF
    for chunk in message.batched(by: 256) {
      for b in chunk {
        let idx = Int((crc ^ UInt32(reflect ? b : reversed(b))) & 0xFF)
        crc = (crc >> 8) ^ Checksum.table32c[idx]
      }
    }
    return (reflect ? crc : reversed(crc)) ^ 0xFFFF_FFFF
  }
  @inlinable final internal func crc16(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt16? = nil) -> Swift.UInt16 {
    var crc: UInt16 = seed != nil ? seed! : 0x0000
    for chunk in message.batched(by: 256) {
      for b in chunk {
        crc = (crc >> 8) ^ Checksum.table16[Int((crc ^ UInt16(b)) & 0xFF)]
      }
    }
    return crc
  }
  @objc deinit
}
extension cryptography.Checksum {
  @inlinable public static func crc32(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    Checksum().crc32(message, seed: seed, reflect: reflect)
  }
  @inlinable public static func crc32c(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    Checksum().crc32c(message, seed: seed, reflect: reflect)
  }
  @inlinable public static func crc16(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt16? = nil) -> Swift.UInt16 {
    Checksum().crc16(message, seed: seed)
  }
}
public enum HTTPModelShortType : Swift.String, Swift.CaseIterable {
  case JSON
  case XML
  case HTML
  case IMAGE
  case OTHER
  public init?(rawValue: Swift.String)
  public typealias AllCases = [cryptography.HTTPModelShortType]
  public typealias RawValue = Swift.String
  public static var allCases: [cryptography.HTTPModelShortType] {
    get
  }
  public var rawValue: Swift.String {
    get
  }
}
extension cryptography.HTTPModelShortType {
  public init(contentType: Swift.String)
}
public class CryptoSwiftBlockDecryptor : cryptography.CryptoSwiftCryptor, cryptography.CryptoSwiftUpdatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal let padding: cryptography.CryptoSwiftPadding
  @usableFromInline
  internal var worker: any cryptography.CryptoSwiftCipherModeWorker
  @usableFromInline
  internal var accumulated: [Swift.UInt8]
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: cryptography.CryptoSwiftPadding, _ worker: any cryptography.CryptoSwiftCipherModeWorker) throws
  @inlinable public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    // If a worker (eg GCM) can combine ciphertext + tag
    // we need to remove tag from the ciphertext.
    if !isLast && self.accumulated.count < self.blockSize + self.worker.additionalBufferSize {
      return []
    }

    let accumulatedWithoutSuffix: Array<UInt8>
    if self.worker.additionalBufferSize > 0 {
      // FIXME: how slow is that?
      accumulatedWithoutSuffix = Array(self.accumulated.prefix(self.accumulated.count - self.worker.additionalBufferSize))
    } else {
      accumulatedWithoutSuffix = self.accumulated
    }

    var processedBytesCount = 0
    var plaintext = Array<UInt8>(reserveCapacity: accumulatedWithoutSuffix.count)
    // Processing in a block-size manner. It's good for block modes, but bad for stream modes.
    for var chunk in accumulatedWithoutSuffix.batched(by: self.blockSize) {
      if isLast || (accumulatedWithoutSuffix.count - processedBytesCount) >= blockSize {
        let isLastChunk = processedBytesCount + chunk.count == accumulatedWithoutSuffix.count

        if isLast, isLastChunk, var finalizingWorker = worker as? CryptoSwiftFinalizingDecryptModeWorker {
          chunk = try finalizingWorker.willDecryptLast(bytes: chunk + accumulated.suffix(worker.additionalBufferSize)) // tag size
        }

        if !chunk.isEmpty {
          plaintext += worker.decrypt(block: chunk)
        }

        if isLast, isLastChunk, var finalizingWorker = worker as? CryptoSwiftFinalizingDecryptModeWorker {
          plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
        }

        processedBytesCount += chunk.count
      }
    }
    accumulated.removeFirst(processedBytesCount) // super-slow

    if isLast {
      if accumulatedWithoutSuffix.isEmpty, var finalizingWorker = worker as? CryptoSwiftFinalizingDecryptModeWorker {
        try finalizingWorker.willDecryptLast(bytes: self.accumulated.suffix(self.worker.additionalBufferSize))
        plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
      }
      plaintext = self.padding.remove(from: plaintext, blockSize: self.blockSize)
    }

    return plaintext
  }
  public func seek(to position: Swift.Int) throws
  @objc deinit
}
extension Foundation.FileManager {
  public static var documentsDirectoryURL: Foundation.URL {
    get
  }
}
public class WSEngine : cryptography.Engine, cryptography.TransportEventClient, cryptography.FramerEventClient, cryptography.FrameCollectorDelegate, cryptography.HTTPHandlerDelegate {
  public var respondToPingWithPong: Swift.Bool
  public init(transport: any cryptography.Transport, certPinner: (any cryptography.CertificatePinning)? = nil, headerValidator: any cryptography.HeaderValidator = FoundationSecurity(), httpHandler: any cryptography.HTTPHandler = FoundationHTTPHandler(), framer: any cryptography.Framer = WSFramer(), compressionHandler: (any cryptography.CompressionHandler)? = nil)
  public func register(delegate: any cryptography.EngineDelegate)
  public func start(request: Foundation.URLRequest)
  public func stop(closeCode: Swift.UInt16 = CloseCode.normal.rawValue)
  public func forceStop()
  public func write(string: Swift.String, completion: (() -> ())?)
  public func write(data: Foundation.Data, opcode: cryptography.FrameOpCode, completion: (() -> ())?)
  public func connectionChanged(state: cryptography.ConnectionState)
  public func didReceiveHTTP(event: cryptography.HTTPEvent)
  public func frameProcessed(event: cryptography.FrameEvent)
  public func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  public func didForm(event: cryptography.FrameCollector.Event)
  @objc deinit
}
extension cryptography.PKCS7 {
  public struct ReceiptInfo {
    public var bundleIdentifier: Swift.String? {
      get
    }
    public var bundleIdentifierData: Foundation.Data? {
      get
    }
    public var bundleVersion: Swift.String? {
      get
    }
    public var originalApplicationVersion: Swift.String? {
      get
    }
    public var opaqueValue: Foundation.Data? {
      get
    }
    public var sha1: Foundation.Data? {
      get
    }
    public var receiptCreationDate: Foundation.Date? {
      get
    }
    public var receiptCreationDateString: Swift.String? {
      get
    }
    public var receiptExpirationDate: Foundation.Date? {
      get
    }
    public var receiptExpirationDateString: Swift.String? {
      get
    }
    public var inAppPurchases: [cryptography.PKCS7.InAppPurchaseInfo]? {
      get
    }
  }
  public struct InAppPurchaseInfo {
    public var quantity: Swift.UInt64? {
      get
    }
    public var productId: Swift.String? {
      get
    }
    public var transactionId: Swift.String? {
      get
    }
    public var originalTransactionId: Swift.String? {
      get
    }
    public var purchaseDate: Foundation.Date? {
      get
    }
    public var originalPurchaseDate: Foundation.Date? {
      get
    }
    public var expiresDate: Foundation.Date? {
      get
    }
    public var isInIntroOfferPeriod: Swift.UInt64? {
      get
    }
    public var cancellationDate: Foundation.Date? {
      get
    }
    public var webOrderLineItemId: Swift.UInt64? {
      get
    }
  }
  public func receipt() -> cryptography.PKCS7.ReceiptInfo?
}
public enum LaodingIndicatorType : Swift.CaseIterable {
  case blank
  case ballPulse
  case ballGridPulse
  case ballClipRotate
  case squareSpin
  case ballClipRotatePulse
  case ballClipRotateMultiple
  case ballPulseRise
  case ballRotate
  case cubeTransition
  case ballZigZag
  case ballZigZagDeflect
  case ballTrianglePath
  case ballScale
  case lineScale
  case lineScaleParty
  case ballScaleMultiple
  case ballPulseSync
  case ballBeat
  case ballDoubleBounce
  case lineScalePulseOut
  case lineScalePulseOutRapid
  case ballScaleRipple
  case ballScaleRippleMultiple
  case ballSpinFadeLoader
  case lineSpinFadeLoader
  case triangleSkewSpin
  case pacman
  case ballGridBeat
  case semiCircleSpin
  case ballRotateChase
  case orbit
  case audioEqualizer
  case circleStrokeSpin
  public static func == (a: cryptography.LaodingIndicatorType, b: cryptography.LaodingIndicatorType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public typealias AllCases = [cryptography.LaodingIndicatorType]
  public static var allCases: [cryptography.LaodingIndicatorType] {
    get
  }
  public var hashValue: Swift.Int {
    get
  }
}
public typealias FadeInAnimation = (UIKit.UIView) -> Swift.Void
public typealias FadeOutAnimation = (UIKit.UIView, @escaping () -> Swift.Void) -> Swift.Void
@objc @_Concurrency.MainActor(unsafe) final public class NVActivityIndicatorView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_TYPE: cryptography.LaodingIndicatorType
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_COLOR: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_TEXT_COLOR: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_PADDING: CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_BLOCKER_SIZE: CoreFoundation.CGSize
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_BLOCKER_DISPLAY_TIME_THRESHOLD: Swift.Int
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_BLOCKER_MINIMUM_DISPLAY_TIME: Swift.Int
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_BLOCKER_MESSAGE: Swift.String?
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_BLOCKER_MESSAGE_SPACING: CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_BLOCKER_MESSAGE_FONT: UIKit.UIFont
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_BLOCKER_BACKGROUND_COLOR: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_FADE_IN_ANIMATION: (_ view: UIKit.UIView) -> Swift.Void
  @_Concurrency.MainActor(unsafe) public static var DEFAULT_FADE_OUT_ANIMATION: (_ view: UIKit.UIView, _ complete: @escaping () -> Swift.Void) -> Swift.Void
  @_Concurrency.MainActor(unsafe) final public var type: cryptography.LaodingIndicatorType
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) final public var color: UIKit.UIColor
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) final public var padding: CoreFoundation.CGFloat
  @available(*, deprecated)
  @_Concurrency.MainActor(unsafe) final public var animating: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var isAnimating: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) public init(frame: CoreFoundation.CGRect, type: cryptography.LaodingIndicatorType? = nil, color: UIKit.UIColor? = nil, padding: CoreFoundation.CGFloat? = nil)
  @_Concurrency.MainActor(unsafe) @objc override final public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override final public var bounds: CoreFoundation.CGRect {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) final public func startAnimating()
  @_Concurrency.MainActor(unsafe) final public func stopAnimating()
  @objc deinit
}
extension cryptography.CryptoSwiftAES : cryptography.CryptoSwiftCryptors {
  @inlinable final public func makeEncryptor() throws -> any cryptography.CryptoSwiftCryptor & cryptography.CryptoSwiftUpdatable {
    let blockSize = blockMode.customBlockSize ?? CryptoSwiftAES.blockSize
    let worker = try blockMode.worker(blockSize: blockSize, cipherOperation: encrypt, encryptionOperation: encrypt)
    if worker is CryptoSwiftStreamModeWorker {
      return try CryptoSwiftStreamEncryptor(blockSize: blockSize, padding: padding, worker)
    }
    return try CryptoSwiftBlockEncryptor(blockSize: blockSize, padding: padding, worker)
  }
  @inlinable final public func makeDecryptor() throws -> any cryptography.CryptoSwiftCryptor & cryptography.CryptoSwiftUpdatable {
    let blockSize = blockMode.customBlockSize ?? CryptoSwiftAES.blockSize
    let cipherOperation: CipherOperationOnBlock = blockMode.options.contains(.useEncryptToDecrypt) == true ? encrypt : decrypt
    let worker = try blockMode.worker(blockSize: blockSize, cipherOperation: cipherOperation, encryptionOperation: encrypt)
    if worker is CryptoSwiftStreamModeWorker {
      return try CryptoSwiftStreamDecryptor(blockSize: blockSize, padding: padding, worker)
    }
    return try CryptoSwiftBlockDecryptor(blockSize: blockSize, padding: padding, worker)
  }
}
@_hasMissingDesignatedInitializers open class PEMEncryptedPrivateKey {
  public enum EncMode {
    case aes128CBC, aes256CBC
    public static func == (a: cryptography.PEMEncryptedPrivateKey.EncMode, b: cryptography.PEMEncryptedPrivateKey.EncMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static func toDER(_ pemKey: Swift.String, passphrase: Swift.String) throws -> Foundation.Data
  public static func toPEM(_ derKey: Foundation.Data, passphrase: Swift.String, mode: cryptography.PEMEncryptedPrivateKey.EncMode) -> Swift.String
  @objc deinit
}
public enum TransactionTypeString : Swift.String {
  case keyGeneration
  case sign
  case signPdf
  case importCert
  case deleteKey
  case publicKeys
  case unKnownType
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol SimpleASN1Writing : AnyObject {
  var encoding: [Swift.UInt8] { get }
  func write(from writer: cryptography.SimpleASN1Writer)
  func write(_ bytes: [Swift.UInt8])
  func write(_ contents: [Swift.UInt8], identifiedBy identifier: Swift.UInt8)
  func wrap(with identifier: Swift.UInt8)
  func wrapBitString()
}
public enum KeyTypeEnum : Swift.String, Swift.Codable {
  case RSA_1024
  case RSA_1280
  case RSA_1536
  case RSA_1984
  case RSA_2048
  case RSA_4096
  public var value: Swift.String {
    get
  }
  public var size: Swift.Int {
    get
  }
  public var type: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum AppStrings {
  public enum Splash : Swift.String {
    case title
    case invalidResponseError
    case invalidSelfError
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ConfirmSign : Swift.String {
    case toolbarTitle
    case title
    case saveButton
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Register : Swift.String {
    case title
    case phoneNumberInput
    case phoneNumberInputPlaceholder
    case requestCodeButton
    case cancelButton
    case pinCodeTitle
    case pinCodeHelpTitle
    case resendOtp
    case otpTitle
    case otpHelp
    case otpConfirmButton
    case savePinCodeButton
    case returnToPhoneNumberButton
    case returnToPhoneNumberAlertTitle
    case returnToPhoneNumberAlertOptionTitle
    case returnToPhoneNumberAlertCancelTitle
    case pinCodeRepeatPasswordPlaceholder
    case pinCodePasswordPlaceholder
    case pinCodeFirstRule
    case pinCodeSecondRule
    case pinCodeThirdRule
    case completeTitle
    case completePasswordInput
    case completeOtpInput
    case completeOtpPlaceholder
    case completePasswordInputPlaceholder
    case completeRepeatPassword
    case completeRepeatPasswordInputPlaceholder
    case completeConfirmButton
    case completeCancelButton
    case remainingTimeToUseOtp
    case termFirstPartTitle
    case termSecondPartTitle
    case termThirdPartTitle
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Login : Swift.String {
    case title
    case passwordTextFieldPlaceholder
    case passwordTextFieldTitle
    case passwordTextFieldErrorValidationCharanterInput
    case passwordTextFieldEmptyError
    case button
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum CertDetials : Swift.String {
    case toollbarTitle
    case title
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum CertList : Swift.String {
    case toolbarTitle
    case title
    case emotyTitle
    case statusTitle
    case certIssuerDistinguishedNameTitle
    case certsCount
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum CertsAPI : Swift.String {
    case certificateOwner
    case notBefore
    case notAfter
    case certStatus
    case certKeyAlgorithm
    case certKeyContainer
    case certificateIssuer
    case keyId
    case serialNumber
    case certStatusUnknown
    case certStatusInvalid
    case certStatusValid
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum BranchOffice : Swift.String {
    case toolbarTitle
    case title
    case emotyTitle
    case searchTitle
    case curator
    case viewDetails
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum BranchOfficeDetails : Swift.String {
    case addressTitle
    case officeCurator
    case phone
    case openInMap
    case cancel
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Home : Swift.String {
    case title
    case settingTabBarItem
    case profileTabBarItem
    case dashboardTabBarItem
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Profile : Swift.String {
    case toolbarTitle
    case title
    case nationalCodeTitle
    case dateTitle
    case uuid
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ChangePassword : Swift.String {
    case toolbarTitle
    case previousPasswordInputTextFieldPlaceholder
    case newPasswordInputTextFieldPlaceholder
    case repeatNewPasswordInputTextFieldPlaceholder
    case button
    case resultOfChangedPassword
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Dashboard : Swift.String {
    case titleLable
    case startButton
    case title
    case serviceExitViewTitle
    case serviceExitViewConfirm
    case userCreatedCertServiceHelpLable
    case userCreatedCertExitLable
    case userCreatedIssueCertLable
    case whenUserCreatedSetting
    case whenUserCreatedTransactionHistory
    case archiveRequestsLable
    case toolbarViewDefualtTitle
    case toolbarViewDefualtSubTitle
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum TransactionHistory : Swift.String {
    case title
    case emptyAlert
    case transactionHistoryCountList
    case filterTransactionTypeTitle
    case filterSelectDateTitle
    case filterDisableTitle
    case keyGenerationTitle
    case signTitle
    case importCertTitle
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum TransactionHistoryDetails : Swift.String {
    case title
    case pdfShowButton
    case transactionTypeTitle
    case dateTitle
    case transactionIdTitle
    case keyIdTitle
    case keyIdValueDefualt
    case resultTitle
    case resultSucces
    case resultFailed
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Payment : Swift.String {
    case toolbarTitle
    case title
    case confirm
    case amountUnit
    case costDetails
    case paymentHelp
    case paymentResultError
    case paymentDiscount
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum AddUserInformation : Swift.String {
    case toolbarTitle
    case title
    case nationalCodeTitle
    case nationalCodePlaceholder
    case selectTimeTitle
    case birthDateSelectTimeLable
    case name
    case family
    case serial
    case confirm
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Ekyc : Swift.String {
    case toolbarTitle
    case help
    case description
    case confirm
    case holdButtonDescription
    case success
    case savedVideoFileError
    case deleteRecoededVideoFileError
    case ekycResultError
    case user_canceled
    case permission_not_granted
    case camera_not_supported
    case unknown_error
    case irro_unavailable
    case personal_image_not_found
    case max_try_exceed
    case liveness_not_detected
    case server_connection_failed
    case face_not_matched
    case file_exceeded
    case preparing_timeout
    case test_video_timeout
    case wrong_captcha
    case test_video_parse_problem
    case camera_bad_angle
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum IssueCertTypeOption : Swift.String {
    case toolbarTitle
    case title
    case virtualButton
    case inBranchButton
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum IssueCertStepsResult : Swift.String {
    case title
    case payment
    case inital
    case keyGenerated
    case csrSigned
    case certCreated
    case certImported
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ResultSuccess : Swift.String {
    case title
    case success‌Button
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Setting : Swift.String {
    case toolbarTitle
    case securitySettings
    case changeLoginPinCode
    case resetPinCode
    case changeScriptSignature
    case accountOperations
    case activateFaceID
    case temporaryDeactivation
    case deleteAccount
    case exitSdk
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ExitSdkString : Swift.String {
    case logout
    case confirm
    case cancel
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum DeleteAccount : Swift.String {
    case title
    case confirm
    case confirmButton
    case cancel
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ViewPdfFileInsertSignature : Swift.String {
    case toolbarTitle
    case enableUsingSign
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ErrorAlert : Swift.String {
    case confirmButton
    case title
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ArchiveRequests : Swift.String {
    case toolBarTitle
    case expireTime
    case type
    case keyGenerationTitle
    case signTitle
    case importCertTitle
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum BranchOffic : Swift.String {
    case searchPlaceholder
    case dialNumberError
    case detailsTitle
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Authenticat : Swift.String {
    case pdfTitle
    case passwordTextFieldPopUpPlaceholder
    case loadingTitle
    case cancel
    case confirm
    case titleLableInCancelAlert
    case archiveTitle
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum Cert : Swift.String {
    case unknownkeyInfoStatusValue
    case invalidkeyInfoStatusValue
    case validkeyInfoStatusValue
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ResetPin : Swift.String {
    case toolbarTitleAddUserInformation
    case titleAddUserInformation
    case newPasswordToolbarTitle
    case titleNewPassword
    case nationalCodeTitle
    case nationalCodePlaceholder
    case serial
    case confirm
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public enum ErrorMessage : Swift.String {
    case textFieldIconErrorValidationCharanterInput
    case PASSWORD_IS_NOT_A_NUMBER
    case PASSWORD_IS_INVALID_CREDENTIALS
    case UPLAUD_SIGN_IMAGE
    case NOT_FOUND_SIGN_IMAGE
    case MAXIMUM_PASSWORD_ATTEMPTS
    case UNKNOWN
    case PASSWORD_IS_NIL
    case PASSWORD_IS_NOT_NUMERIC
    case PASSWORD_IS_NOT_ALPHANUMERIC
    case PASSWORD_IS_NOT_ALPHA_NUMERIC_SYMBOL
    case PASSWORD_IS_NOT_ALPHA_NUMERIC_COMPLEX
    case PASSWORD_IS_NOT_ALPHA_NUMERIC_SYMBOL_NUMERIC_SYMBOL
    case PASSWORD_IS_NOT_NUMBER
    case PASSWORD_LENGTH_IS_INCORRECT
    case GENERAL
    case MOBILE_FORMAT
    case OTP_IS_NIL
    case PASSWORD_CONFIRM_DID_NOT_MATCH
    case NATIONAL_CODE_IS_NIL
    case NATIONAL_CODE_IS_INCORRECT_FORMAT
    case BIRTH_DAY_IS_NIL
    case SERIAL_BEHIND_THE_NATIONAL_SMART_CARD_VALUE_IS_NIL
    case NAME_IS_NIL
    case NAME_IS_NOT_ENGLIDH
    case FAMILY_IS_NIL
    case Family_Is_Not_Englidh
    case USER_INFO_NOT_FOUND
    case RA_ISSUE_IN_PROGRESS
    case RA_INTERNAL_ERROR
    case RA_UNKNOWN_ERROR
    case RA_WRONG_PARAM
    case RA_MISSING_PARAM
    case RA_USER_PROFILE_NOT_FOUND
    case RA_USER_WAS_DEAD
    case RA_USER_PROFILE_PROVIDER_CONNECTION_ERROR
    case RA_PHONE_POSSESSION_PROFILE_NOT_FOUND
    case RA_PHONE_POSSESSION_INVALID
    case RA_PHONE_POSSESSION_PROFILE_PROVIDER_CONNECTION_ERROR
    case RA_CERT_NOT_FOUND
    case RA_CA_AUTHENTICATION_FAILED
    case RA_CA_CONNECTION_PROBLEM
    case RA_CERT_REVOKED_FORMERLY
    case RA_TX_NOT_FOUND
    case RA_CERT_REVOKED_PROBLEM
    case RA_MSSP_CONNECTION_ERROR
    case RA_PAYMENT_REQUIRED
    case RA_PAYMENT_PROVIDER_CONNECTION_ERROR
    case RA_PAYMENT_PROVIDER_REQUEST_FAILED
    case RA_PAYMENT_DUPLICATE_ERROR
    case RA_PAYMENT_INVALID_PAYMENT_TICKET_CODE
    case RA_PAYMENT_INVALID_PAYMENT_TRACING_CODE
    case RA_INVALID_EKYC_TRACKING_CODE
    case RA_EKYC_PROVIDER_CONNECTION_ERROR
    case RA_EKYC_UNKNOWN_ERROR
    case CERTIFICATE_CONTENT_PARSING
    case NotAfterValueInCertificate
    case InvalidCertificate
    case NotBeforeValueInCertificate
    case NETWORK_NOT_REACHABLE
    case UNABLE_TO_PROVIDE_URL_SESSION
    case INVALID_URL_COMPONENTS
    case TIME_OUT
    case BAD_REQUEST
    case UNAUTHORIZED
    case FORBIDDEN
    case NOT_FOUND
    case SERVICE_UN_AVAILABLE
    case INTERNAL_SERVERE
    case DATA_IS_NIL
    case JSON_DESERIALIZE_VALUE
    case NONE_USER
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
}
@usableFromInline
internal struct CryptoSwiftBatchedCollectionIndex<Base> where Base : Swift.Collection {
}
extension cryptography.CryptoSwiftBatchedCollectionIndex : Swift.Comparable {
  @usableFromInline
  internal static func == <Base>(lhs: cryptography.CryptoSwiftBatchedCollectionIndex<Base>, rhs: cryptography.CryptoSwiftBatchedCollectionIndex<Base>) -> Swift.Bool where Base : Swift.Collection
  @usableFromInline
  internal static func < <Base>(lhs: cryptography.CryptoSwiftBatchedCollectionIndex<Base>, rhs: cryptography.CryptoSwiftBatchedCollectionIndex<Base>) -> Swift.Bool where Base : Swift.Collection
}
@usableFromInline
internal struct BatchedCollection<Base> : Swift.Collection where Base : Swift.Collection {
  @usableFromInline
  internal init(base: Base, size: Swift.Int)
  @usableFromInline
  internal typealias Index = cryptography.CryptoSwiftBatchedCollectionIndex<Base>
  @usableFromInline
  internal var startIndex: cryptography.BatchedCollection<Base>.Index {
    get
  }
  @usableFromInline
  internal var endIndex: cryptography.BatchedCollection<Base>.Index {
    get
  }
  @usableFromInline
  internal func index(after idx: cryptography.BatchedCollection<Base>.Index) -> cryptography.BatchedCollection<Base>.Index
  @usableFromInline
  internal subscript(idx: cryptography.BatchedCollection<Base>.Index) -> Base.SubSequence {
    get
  }
  @usableFromInline
  internal typealias Element = Base.SubSequence
  @usableFromInline
  internal typealias Indices = Swift.DefaultIndices<cryptography.BatchedCollection<Base>>
  @usableFromInline
  internal typealias Iterator = Swift.IndexingIterator<cryptography.BatchedCollection<Base>>
  @usableFromInline
  internal typealias SubSequence = Swift.Slice<cryptography.BatchedCollection<Base>>
}
extension Swift.Collection {
  @inlinable internal func batched(by size: Swift.Int) -> cryptography.BatchedCollection<Self> {
    BatchedCollection(base: self, size: size)
  }
}
public class StringHTTPHandler : cryptography.HTTPHandler {
  public init()
  public func convert(request: Foundation.URLRequest) -> Foundation.Data
  public func parse(data: Foundation.Data) -> Swift.Int
  public func register(delegate: any cryptography.HTTPHandlerDelegate)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ASN1Object : Swift.CustomStringConvertible {
  public var rawValue: Foundation.Data?
  public var value: Any?
  public var identifier: cryptography.ASN1Identifier?
  weak public var parent: cryptography.ASN1Object? {
    get
  }
  public func sub(_ index: Swift.Int) -> cryptography.ASN1Object?
  public func subCount() -> Swift.Int
  public func findOid(_ oid: cryptography.OID) -> cryptography.ASN1Object?
  public func findOid(_ oid: Swift.String) -> cryptography.ASN1Object?
  public var description: Swift.String {
    get
  }
  public var asString: Swift.String? {
    get
  }
  @objc deinit
}
public enum CryptoSwiftPKCS7 {
}
public let notificationPrinterLogAdded: Swift.String
public enum LogType {
  case success
  case error
  case warning
  case information
  case alert
  case plain
  case splash
  case onboarding
  case home
  case certDetails
  case certList
  case changePassword
  case dashboard
  case deleteKey
  case RaPayment
  case RaAddUserInformation
  case RaEkyc
  case RaSelectIssueTypeOption
  case RaSteps
  case RaResultSuccess
  case lockView
  case login
  case keyGenerate
  case sign
  case signUrlPdf
  case profile
  case registerByMobile
  case registerBySignedMsisdn
  case setting
  case transactionHistory
  case transactionHistoryDetails
  case viewPdfFileInsertSignature
  case confirmSign
  case msau
  case cryptoLib
  case restfulAPI
  case websocket
  case database
  case userDefualt
  case keyChain
  public static func == (a: cryptography.LogType, b: cryptography.LogType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers final public class TraceInfo {
  final public var fileName: Swift.String {
    get
  }
  final public var functionName: Swift.String {
    get
  }
  final public var lineNumber: Swift.Int {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class PLog {
  final public var id: Swift.String
  final public var details: Swift.String
  final public var logType: cryptography.LogType
  final public var time: Swift.String
  final public var traceInfo: cryptography.TraceInfo
  final public var printableLog: Swift.String {
    get
  }
  final public var printableTrace: Swift.String {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class Printer {
  public static let log: cryptography.Printer
  final public var plainLog: Swift.Bool
  final public var addLineAfterEachPrint: Swift.Bool
  final public var capitalizeTitles: Swift.Bool
  final public var capitalizeDetails: Swift.Bool
  final public var printOnlyIfDebugMode: Swift.Bool
  final public var hideLogsTime: Swift.Bool
  final public var disable: Swift.Bool
  final public var keepTracking: Swift.Bool
  final public var keepAutoTracing: Swift.Bool
  final public var onLogCompletion: ((_ printLog: Swift.String, _ fileName: Swift.String, _ functionName: Swift.String, _ lineNumber: Swift.Int) -> ())?
  final public var logDateFormat: Swift.String {
    get
    set(newValue)
  }
  final public func skipFile(filename: Swift.String = #file)
  final public func addFile(filename: Swift.String = #file)
  final public var filterLogs: Swift.Array<cryptography.LogType> {
    get
    set(newArray)
  }
  final public func saveLogsToFile(logs arrayLog: Swift.Array<cryptography.PLog>)
  final public func deleteLogFiles()
  final public func flush()
  final public func addAppEventsHandler()
  final public func removeAppEventsHandler()
  final public func getAllLogs() -> Swift.Array<cryptography.PLog>
  final public func getAllLogs(filterLogTypes: Swift.Array<cryptography.LogType>) -> Swift.Array<cryptography.PLog>
  final public func all(showTrace: Swift.Bool)
  final public func all(filterLogTypes: Swift.Array<cryptography.LogType>, showTrace: Swift.Bool)
  final public func show(id: Swift.String, details: Swift.String, logType lType: cryptography.LogType, fileName: Swift.String = #file, lineNumber: Swift.Int = #line, functionName: Swift.String = #function)
  final public func trace(fileName: Swift.String = #file, lineNumber: Swift.Int = #line, functionName: Swift.String = #function)
  final public func showInFuture(id: Swift.String, details: Swift.String, logType lType: cryptography.LogType, afterSeconds seconds: Swift.Double, fileName: Swift.String = #file, lineNumber: Swift.Int = #line, functionName: Swift.String = #function)
  final public func show(details: Swift.String, logType lType: cryptography.LogType, fileName: Swift.String = #file, lineNumber: Swift.Int = #line, functionName: Swift.String = #function)
  final public func success(details: Swift.String, fileName: Swift.String = #file, lineNumber: Swift.Int = #line, functionName: Swift.String = #function)
  final public func error(details: Swift.String, fileName: Swift.String = #file, lineNumber: Swift.Int = #line, functionName: Swift.String = #function)
  final public func warning(details: Swift.String, fileName: Swift.String = #file, lineNumber: Swift.Int = #line, functionName: Swift.String = #function)
  final public func information(details: Swift.String, fileName: Swift.String = #file, lineNumber: Swift.Int = #line, functionName: Swift.String = #function)
  final public func alert(details: Swift.String, fileName: Swift.String = #file, lineNumber: Swift.Int = #line, functionName: Swift.String = #function)
  final public func success(id: Swift.String, details: Swift.String, fileName: Swift.String = #file, lineNumber: Swift.Int = #line, functionName: Swift.String = #function)
  final public func error(id: Swift.String, details: Swift.String, fileName: Swift.String = #file, lineNumber: Swift.Int = #line, functionName: Swift.String = #function)
  final public func information(id: Swift.String, details: Swift.String, fileName: Swift.String = #file, lineNumber: Swift.Int = #line, functionName: Swift.String = #function)
  final public func warning(id: Swift.String, details: Swift.String, fileName: Swift.String = #file, lineNumber: Swift.Int = #line, functionName: Swift.String = #function)
  final public func alert(id: Swift.String, details: Swift.String, fileName: Swift.String = #file, lineNumber: Swift.Int = #line, functionName: Swift.String = #function)
  final public func hideEmojis()
  final public var arrowSymbol: Swift.String {
    get
    set(newValue)
  }
  final public var starSymbol: Swift.String {
    get
    set(newValue)
  }
  final public var successEmojiSymbol: Swift.String {
    get
    set(newValue)
  }
  final public var errorEmojiSymbol: Swift.String {
    get
    set(newValue)
  }
  final public var warningEmojiSymbol: Swift.String {
    get
    set(newValue)
  }
  final public var infoEmojiSymbol: Swift.String {
    get
    set(newValue)
  }
  final public var alertEmojiSymbol: Swift.String {
    get
    set(newValue)
  }
  final public var watchEmojiSymbol: Swift.String {
    get
    set(newValue)
  }
  final public var idEmojiSymbol: Swift.String {
    get
    set(newValue)
  }
  final public var encryptionEmojiSymbol: Swift.String {
    get
    set(newValue)
  }
  @objc deinit
}
public class WSCompression : cryptography.CompressionHandler {
  public init()
  public func load(headers: [Swift.String : Swift.String])
  public func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  public func compress(data: Foundation.Data) -> Foundation.Data?
  @objc deinit
}
public enum FoundationSecurityError : Swift.Error {
  case invalidRequest
  public static func == (a: cryptography.FoundationSecurityError, b: cryptography.FoundationSecurityError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class FoundationSecurity {
  public init(allowSelfSigned: Swift.Bool = false)
  @objc deinit
}
extension cryptography.FoundationSecurity : cryptography.CertificatePinning {
  public func evaluateTrust(trust: Security.SecTrust, domain: Swift.String?, completion: ((cryptography.PinningState) -> ()))
}
extension cryptography.FoundationSecurity : cryptography.HeaderValidator {
  public func validate(headers: [Swift.String : Swift.String], key: Swift.String) -> (any Swift.Error)?
}
public enum SecurityErrorCode : Swift.UInt16 {
  case acceptFailed
  case pinningFailed
  public init?(rawValue: Swift.UInt16)
  public typealias RawValue = Swift.UInt16
  public var rawValue: Swift.UInt16 {
    get
  }
}
public enum PinningState {
  case success
  case failed(CoreFoundation.CFError?)
}
public protocol CertificatePinning : AnyObject {
  func evaluateTrust(trust: Security.SecTrust, domain: Swift.String?, completion: ((cryptography.PinningState) -> ()))
}
public protocol HeaderValidator : AnyObject {
  func validate(headers: [Swift.String : Swift.String], key: Swift.String) -> (any Swift.Error)?
}
public enum KeyStoreEditorError : Darwin.OSStatus, Swift.Error {
  case unimplemented
  case param
  case allocate
  case notAvailable
  case authFailed
  case duplicateItem
  case itemNotFound
  case interactionNotAllowed
  case decode
  case missingEntitlement
  public static var debugLevel: Swift.Int
  public init?(rawValue: Darwin.OSStatus)
  public typealias RawValue = Darwin.OSStatus
  public var rawValue: Darwin.OSStatus {
    get
  }
}
public protocol CryptoSwiftUpdatable {
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8>
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws
}
extension cryptography.CryptoSwiftUpdatable {
  @inlinable public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    let processed = try update(withBytes: bytes, isLast: isLast)
    if !processed.isEmpty {
      output(processed)
    }
  }
  @inlinable public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes, isLast: isLast)
  }
  @inlinable public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes.slice, isLast: isLast)
  }
  @inlinable public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.update(withBytes: bytes.slice, isLast: isLast, output: output)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes, isLast: true)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    try self.finish(withBytes: bytes.slice)
  }
  @inlinable public mutating func finish() throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: [], isLast: true)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    let processed = try update(withBytes: bytes, isLast: true)
    if !processed.isEmpty {
      output(processed)
    }
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.finish(withBytes: bytes.slice, output: output)
  }
  @inlinable public mutating func finish(output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.finish(withBytes: [], output: output)
  }
}
public protocol RSAPublicKeyImporting {
  func fromSubjectPublicKeyInfo(_ subjectPublicKeyInfo: Foundation.Data) throws -> Foundation.Data
}
public struct CryptoSwiftECB : cryptography.CryptoSwiftBlockMode {
  public let options: cryptography.CryptoSwiftBlockModeOption
  public let customBlockSize: Swift.Int?
  public init()
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping cryptography.CipherOperationOnBlock, encryptionOperation: @escaping cryptography.CipherOperationOnBlock) throws -> any cryptography.CryptoSwiftCipherModeWorker
}
public struct EkycResult {
  public init(error: Swift.String?, trackingCode: Swift.String?)
}
public struct EkycUserInfo : Swift.Codable {
  public var phoneNum: Swift.String?
  public var name: Swift.String?
  public var family: Swift.String?
  public var nationalId: Swift.String
  public var birthYear: Swift.String?
  public var birthMonth: Swift.String?
  public var birthDayOfMonth: Swift.String?
  public var cardSerialNum: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public struct EkycUserInfoCustomJwtToke {
  public var jwtToke: Swift.String
}
public struct EkycVideoFile {
  public var name: Swift.String
  public var path: Foundation.URL
}
public struct EkycSetting {
  public init(name: Swift.String, livenessVoiceCaptchaText: Swift.String?, livenessGestureCaptchaText: Swift.String?, captureQuality: Swift.String, videoTime: Swift.Int)
}
final public class CryptoSwiftOCB : cryptography.CryptoSwiftBlockMode {
  public enum Mode {
    case combined
    case detached
    public static func == (a: cryptography.CryptoSwiftOCB.Mode, b: cryptography.CryptoSwiftOCB.Mode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let options: cryptography.CryptoSwiftBlockModeOption
  public enum Error : Swift.Error {
    case invalidNonce
    case fail
    public static func == (a: cryptography.CryptoSwiftOCB.Error, b: cryptography.CryptoSwiftOCB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let customBlockSize: Swift.Int?
  final public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(nonce N: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, tagLength: Swift.Int = 16, mode: cryptography.CryptoSwiftOCB.Mode = .detached)
  @inlinable convenience public init(nonce N: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, mode: cryptography.CryptoSwiftOCB.Mode = .detached) {
    self.init(nonce: N, additionalAuthenticatedData: additionalAuthenticatedData, tagLength: authenticationTag.count, mode: mode)
    self.authenticationTag = authenticationTag
  }
  final public func worker(blockSize: Swift.Int, cipherOperation: @escaping cryptography.CipherOperationOnBlock, encryptionOperation: @escaping cryptography.CipherOperationOnBlock) throws -> any cryptography.CryptoSwiftCipherModeWorker
  @objc deinit
}
@_hasMissingDesignatedInitializers open class DH {
  open class DH {
    public init(dhParam: cryptography.DHParam) throws
    open func generateKey() throws -> Foundation.Data
    open func computeKey(_ peerKey: Foundation.Data) throws -> Foundation.Data
    @objc deinit
  }
  public static func available() -> Swift.Bool
  @objc deinit
}
@_inheritsConvenienceInitializers final public class CBCMAC : cryptography.CryptoSwiftCMAC {
  override final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  override public init(key: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(*, deprecated, message: "Use OID instead")
public class ASN1DistinguishedNames {
  final public let oid: Swift.String
  final public let representation: Swift.String
  public static let commonName: cryptography.ASN1DistinguishedNames
  public static let dnQualifier: cryptography.ASN1DistinguishedNames
  public static let serialNumber: cryptography.ASN1DistinguishedNames
  public static let givenName: cryptography.ASN1DistinguishedNames
  public static let surname: cryptography.ASN1DistinguishedNames
  public static let organizationalUnitName: cryptography.ASN1DistinguishedNames
  public static let organizationName: cryptography.ASN1DistinguishedNames
  public static let streetAddress: cryptography.ASN1DistinguishedNames
  public static let localityName: cryptography.ASN1DistinguishedNames
  public static let stateOrProvinceName: cryptography.ASN1DistinguishedNames
  public static let countryName: cryptography.ASN1DistinguishedNames
  public static let email: cryptography.ASN1DistinguishedNames
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ASN1DistinguishedNameFormatter {
  public static var separator: Swift.String
  @objc deinit
}
public enum KeyConvertError : Swift.Error {
  case invalidKey
  case badPassphrase
  case keyNotEncrypted
  public static var debugLevel: Swift.Int
  public static func == (a: cryptography.KeyConvertError, b: cryptography.KeyConvertError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension cryptography.CryptoSwiftRabbit {
  convenience public init(key: Swift.String) throws
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
@_hasMissingDesignatedInitializers public class X509Extension {
  public var oid: Swift.String? {
    get
  }
  public var name: Swift.String? {
    get
  }
  public var isCritical: Swift.Bool {
    get
  }
  public var value: Any? {
    get
  }
  @objc deinit
}
extension Foundation.Data {
  public func checksum() -> Swift.UInt16
  public func md5() -> Foundation.Data
  public func sha1() -> Foundation.Data
  public func sha224() -> Foundation.Data
  public func sha256() -> Foundation.Data
  public func sha384() -> Foundation.Data
  public func sha512() -> Foundation.Data
  public func sha3(_ variant: cryptography.CryptoSwiftSHA3.Variant) -> Foundation.Data
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc16(seed: Swift.UInt16? = nil) -> Foundation.Data
  public func encrypt(cipher: any cryptography.CryptoSwiftCipher) throws -> Foundation.Data
  public func decrypt(cipher: any cryptography.CryptoSwiftCipher) throws -> Foundation.Data
  public func authenticate(with authenticator: any cryptography.CryptoSwiftAuthenticator) throws -> Foundation.Data
}
extension Foundation.Data {
  public init(hex: Swift.String)
  public var bytesInCryptoSwift: Swift.Array<Swift.UInt8> {
    get
  }
  public func toHexString() -> Swift.String
}
@_hasMissingDesignatedInitializers open class KeyConvertPublicKey {
  public static func pemToPKCS1DER(_ pemKey: Swift.String) throws -> Foundation.Data
  public static func pemToPKCS8DER(_ pemKey: Swift.String) throws -> Foundation.Data
  public static func derToPKCS1PEM(_ derKey: Foundation.Data) -> Swift.String
  public static func derToPKCS8PEM(_ derKey: Foundation.Data) -> Swift.String
  @objc deinit
}
public struct UserInfo : Swift.Codable {
  public var mobile: Swift.String?
  public var nationalCode: Swift.String?
  public var birthDate: Swift.String?
  public var name: Swift.String?
  public var family: Swift.String?
  public var serialBehindTheNationalSmartCardValue: Swift.String?
  public init(mobile: Swift.String?, nationalCode: Swift.String?, birthDate: Swift.String?, name: Swift.String?, family: Swift.String?, serialBehindTheNationalSmartCardValue: Swift.String?)
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
extension UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) public func hideKeyboardWhenTappedAround()
  @objc @_Concurrency.MainActor(unsafe) dynamic public func dismissKeyboard()
}
extension UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public func makeCircular()
}
extension UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public func clearConstraints()
}
extension UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) public func setStatusBar(color: UIKit.UIColor)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class ClickListener : UIKit.UITapGestureRecognizer {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(target: Any?, action: ObjectiveC.Selector?)
  @objc deinit
}
extension UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public func setShadow()
  @_Concurrency.MainActor(unsafe) public func setShadow(opacity: Swift.Float = 1, radius: CoreFoundation.CGFloat, shadowColor: CoreGraphics.CGColor, shadowOffset: CoreFoundation.CGSize)
  @_Concurrency.MainActor(unsafe) public func roundCorners(corners: UIKit.UIRectCorner, radius: CoreFoundation.CGSize, roundedRect: CoreFoundation.CGRect)
  @available(iOS 13.0, *)
  @_Concurrency.MainActor(unsafe) public func roundCorners(corners: UIKit.UIRectCorner, radius: CoreFoundation.CGFloat, bgColor: UIKit.UIColor = .white, cornerCurve: QuartzCore.CALayerCornerCurve = .continuous, shadowColor: UIKit.UIColor = .clear, shadowOffset: CoreFoundation.CGSize = CGSize.zero, shadowOpacity: Swift.Float = 0, shadowRadius: CoreFoundation.CGFloat = 0, boundsInset: UIKit.UIEdgeInsets = UIEdgeInsets(top: 0, left: 0, bottom: 0, right: 0))
  @_Concurrency.MainActor(unsafe) public func roundCornersInOld(corners: UIKit.UIRectCorner, radius: CoreFoundation.CGFloat, bgColor: UIKit.UIColor = .white, shadowColor: UIKit.UIColor = .clear, shadowOffset: CoreFoundation.CGSize = CGSize.zero, shadowOpacity: Swift.Float = 0, shadowRadius: CoreFoundation.CGFloat = 0, boundsInset: UIKit.UIEdgeInsets = UIEdgeInsets(top: 0, left: 0, bottom: 0, right: 0))
  @_Concurrency.MainActor(unsafe) public func addSwipeGestureAllDirection(action: ObjectiveC.Selector)
  @_Concurrency.MainActor(unsafe) public func showWithAnimation(duration: Foundation.TimeInterval = 0.3, options: UIKit.UIView.AnimationOptions = [.curveEaseIn])
  @_Concurrency.MainActor(unsafe) public func hideWithAnimation(duration: Foundation.TimeInterval = 0.3, options: UIKit.UIView.AnimationOptions = [.curveEaseOut])
  @_Concurrency.MainActor(unsafe) public func setOnClickListener(action: @escaping () -> Swift.Void)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func onViewClicked(sender: cryptography.ClickListener)
}
extension UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public func isSmallPhone(completion: @escaping (Swift.Bool) -> Swift.Void)
  @_Concurrency.MainActor(unsafe) public func anchor(top: UIKit.NSLayoutYAxisAnchor?, left: UIKit.NSLayoutXAxisAnchor?, bottom: UIKit.NSLayoutYAxisAnchor?, right: UIKit.NSLayoutXAxisAnchor?, paddingTop: CoreFoundation.CGFloat, paddingLeft: CoreFoundation.CGFloat, paddingBottom: CoreFoundation.CGFloat, paddingRight: CoreFoundation.CGFloat, width: CoreFoundation.CGFloat, height: CoreFoundation.CGFloat, enableInsets: Swift.Bool)
  @_Concurrency.MainActor(unsafe) public func fadeIn(duration: Foundation.TimeInterval = 1.0)
  @_Concurrency.MainActor(unsafe) public func fadeOut(duration: Foundation.TimeInterval = 1.0)
}
@inlinable internal func rotateLeft(_ value: Swift.UInt8, by: Swift.UInt8) -> Swift.UInt8 {
  ((value << by) & 0xff) | (value >> (8 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt16, by: Swift.UInt16) -> Swift.UInt16 {
  ((value << by) & 0xffff) | (value >> (16 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt32, by: Swift.UInt32) -> Swift.UInt32 {
  ((value << by) & 0xffffffff) | (value >> (32 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt64, by: Swift.UInt64) -> Swift.UInt64 {
  (value << by) | (value >> (64 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt16, by: Swift.UInt16) -> Swift.UInt16 {
  (value >> by) | (value << (16 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt32, by: Swift.UInt32) -> Swift.UInt32 {
  (value >> by) | (value << (32 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt64, by: Swift.UInt64) -> Swift.UInt64 {
  ((value >> by) | (value << (64 - by)))
}
@inlinable internal func reversed(_ uint8: Swift.UInt8) -> Swift.UInt8 {
  var v = uint8
  v = (v & 0xf0) >> 4 | (v & 0x0f) << 4
  v = (v & 0xcc) >> 2 | (v & 0x33) << 2
  v = (v & 0xaa) >> 1 | (v & 0x55) << 1
  return v
}
@inlinable internal func reversed(_ uint32: Swift.UInt32) -> Swift.UInt32 {
  var v = uint32
  v = ((v >> 1) & 0x55555555) | ((v & 0x55555555) << 1)
  v = ((v >> 2) & 0x33333333) | ((v & 0x33333333) << 2)
  v = ((v >> 4) & 0x0f0f0f0f) | ((v & 0x0f0f0f0f) << 4)
  v = ((v >> 8) & 0x00ff00ff) | ((v & 0x00ff00ff) << 8)
  v = ((v >> 16) & 0xffff) | ((v & 0xffff) << 16)
  return v
}
@inlinable internal func xor<T, V>(_ left: T, _ right: V) -> Swift.ArraySlice<Swift.UInt8> where T : Swift.RandomAccessCollection, V : Swift.RandomAccessCollection, T.Element == Swift.UInt8, T.Index == Swift.Int, V.Element == Swift.UInt8, V.Index == Swift.Int {
  return xor(left, right).slice
}
@inlinable internal func xor<T, V>(_ left: T, _ right: V) -> Swift.Array<Swift.UInt8> where T : Swift.RandomAccessCollection, V : Swift.RandomAccessCollection, T.Element == Swift.UInt8, T.Index == Swift.Int, V.Element == Swift.UInt8, V.Index == Swift.Int {
  let length = Swift.min(left.count, right.count)

  let buf = UnsafeMutablePointer<UInt8>.allocate(capacity: length)
  buf.initialize(repeating: 0, count: length)
  defer {
    buf.deinitialize(count: length)
    buf.deallocate()
  }

  // xor
  for i in 0..<length {
    buf[i] = left[left.startIndex.advanced(by: i)] ^ right[right.startIndex.advanced(by: i)]
  }

  return Array(UnsafeBufferPointer(start: buf, count: length))
}
@inline(__always) @inlinable internal func bitPadding(to data: inout Swift.Array<Swift.UInt8>, blockSize: Swift.Int, allowance: Swift.Int = 0) {
  let msgLength = data.count
  // Step 1. Append Padding Bits
  // append one bit (UInt8 with one bit) to message
  data.append(0x80)

  // Step 2. append "0" bit until message length in bits ≡ 448 (mod 512)
  let max = blockSize - allowance // 448, 986
  if msgLength % blockSize < max { // 448
    data += Array<UInt8>(repeating: 0, count: max - 1 - (msgLength % blockSize))
  } else {
    data += Array<UInt8>(repeating: 0, count: blockSize + max - 1 - (msgLength % blockSize))
  }
}
public enum CryptoSwiftBit : Swift.Int {
  case zero
  case one
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension cryptography.CryptoSwiftBit {
  @inlinable internal func inverted() -> cryptography.CryptoSwiftBit {
    self == .zero ? .one : .zero
  }
}
extension cryptography.X509Certificate {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class BasicConstraintExtension : cryptography.X509Extension {
    public var isCA: Swift.Bool {
      get
    }
    public var pathLenConstraint: Swift.UInt64? {
      get
    }
    @objc deinit
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class SubjectKeyIdentifierExtension : cryptography.X509Extension {
    override public var value: Any? {
      get
    }
    @objc deinit
  }
  public struct AuthorityInfoAccess {
    public let method: Swift.String
    public let location: Swift.String
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class AuthorityInfoAccessExtension : cryptography.X509Extension {
    public var infoAccess: [cryptography.X509Certificate.AuthorityInfoAccess]? {
      get
    }
    @objc deinit
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class AuthorityKeyIdentifierExtension : cryptography.X509Extension {
    public var keyIdentifier: Foundation.Data? {
      get
    }
    public var certificateIssuer: [Swift.String]? {
      get
    }
    public var serialNumber: Foundation.Data? {
      get
    }
    @objc deinit
  }
  public struct CertificatePolicyQualifier {
    public let oid: Swift.String
    public let value: Swift.String?
  }
  public struct CertificatePolicy {
    public let oid: Swift.String
    public let qualifiers: [cryptography.X509Certificate.CertificatePolicyQualifier]?
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class CertificatePoliciesExtension : cryptography.X509Extension {
    public var policies: [cryptography.X509Certificate.CertificatePolicy]? {
      get
    }
    @objc deinit
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class CRLDistributionPointsExtension : cryptography.X509Extension {
    public var crls: [Swift.String]? {
      get
    }
    @objc deinit
  }
}
public class MSSUIKitConfigBuilder {
  public init()
  public var pageBackgroundResId: UIKit.UIColor
  public func setLaodingIndicatorType(indicatorType: cryptography.LaodingIndicatorType) -> cryptography.MSSUIKitConfigBuilder
  public func setShowSplash(show: Swift.Bool) -> cryptography.MSSUIKitConfigBuilder
  public func setPageBackgroundResId(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setTitleTextInDashboardToolbar(text: Swift.String) -> cryptography.MSSUIKitConfigBuilder
  public func setSubTitleTextInDashboardToolbar(text: Swift.String) -> cryptography.MSSUIKitConfigBuilder
  public func setTitleTextInToolbarColorResId(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setButtonBackgroundColorResId(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setButtonBorderColorResId(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setButtonTextColorResId(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setButtonBackgroundColorSecondlyResId(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setButtonCornerRadiusDimenResId(size: CoreFoundation.CGFloat) -> cryptography.MSSUIKitConfigBuilder
  public func setButtonBorderWidthDimenResId(size: CoreFoundation.CGFloat) -> cryptography.MSSUIKitConfigBuilder
  public func setButtonFont(font: UIKit.UIFont) -> cryptography.MSSUIKitConfigBuilder
  public func setBackButtonBackgroundColorResId(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setBackButtonTextColorResId(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setBackButtonCornerRadiusDimenResId(size: CoreFoundation.CGFloat) -> cryptography.MSSUIKitConfigBuilder
  public func setBackButtonBorderWidthDimenResId(size: CoreFoundation.CGFloat) -> cryptography.MSSUIKitConfigBuilder
  public func setBackButtonBorderColorResId(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setBackButtonFont(font: UIKit.UIFont) -> cryptography.MSSUIKitConfigBuilder
  public func setTitleTextColorResId(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setTitleTextViewFont(font: UIKit.UIFont) -> cryptography.MSSUIKitConfigBuilder
  public func setSubTitleTextColor(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setSubTitleTextViewFont(font: UIKit.UIFont) -> cryptography.MSSUIKitConfigBuilder
  public func setNameTextColorInCertDetials(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setValueTextColorInCertDetials(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setEditTextBackgroundColorResId(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setEditTextFilledBorderColorResId(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setEditTextEmptyBorderColorResId(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setEditTextColorInputInValid(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setEditTextColorInputValidFilled(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setEditTextPlaceholderColorResId(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setEditTextCursorColor(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setEditTextCornerRadiusDimenResId(size: CoreFoundation.CGFloat) -> cryptography.MSSUIKitConfigBuilder
  public func setEditTextBorderWidthDimenResId(size: CoreFoundation.CGFloat) -> cryptography.MSSUIKitConfigBuilder
  public func editTextFont(font: UIKit.UIFont) -> cryptography.MSSUIKitConfigBuilder
  public func setLogoDrawableResId(logoImage: UIKit.UIImage) -> cryptography.MSSUIKitConfigBuilder
  public func setPopUpTypeView(type: cryptography.PopUpTypeView) -> cryptography.MSSUIKitConfigBuilder
  public func setRegistrationBySignedMsisdnTypeView(type: cryptography.RegistrationBySignedMsisdnTypeView) -> cryptography.MSSUIKitConfigBuilder
  public func setUserCanDrawingSignImage(_ type: Swift.Bool) -> cryptography.MSSUIKitConfigBuilder
  public func setPaymentDetailsVisibility(_ type: Swift.Bool) -> cryptography.MSSUIKitConfigBuilder
  public func setPaymentDiscountCodeVisibility(_ type: Swift.Bool) -> cryptography.MSSUIKitConfigBuilder
  public func setUserCanLogoutFromSdk(_ type: Swift.Bool) -> cryptography.MSSUIKitConfigBuilder
  public func setDefaultPhoneNumber(_ phoneNumber: Swift.String) -> cryptography.MSSUIKitConfigBuilder
  public func setDefaultNationalCode(_ nationalNumber: Swift.String) -> cryptography.MSSUIKitConfigBuilder
  public func setPopUpTitleTextColorResId(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setPopUpTitleTextViewFont(font: UIKit.UIFont) -> cryptography.MSSUIKitConfigBuilder
  public func setPopUpDisplayMessageTextColorResId(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setPopUpDisplayMessageTextViewFont(font: UIKit.UIFont) -> cryptography.MSSUIKitConfigBuilder
  public func setEkycProvider(msauEkycProviderProtocol: any cryptography.MsauEkycProviderProtocol) -> cryptography.MSSUIKitConfigBuilder
  public func setMsauIssueCertResultProtocol(msauIssueCertResultProtocol: any cryptography.MsauIssueCertResultProtocol) -> cryptography.MSSUIKitConfigBuilder
  public func setMsauSocketMessageProtocol(msauSocketMessageProtocol: any cryptography.MsauSocketMessageProtocol) -> cryptography.MSSUIKitConfigBuilder
  public func setSdkAsMainApplication(status: Swift.Bool) -> cryptography.MSSUIKitConfigBuilder
  public func setSelectedLanguage(language: cryptography.MsauLanguagesEnum) -> cryptography.MSSUIKitConfigBuilder
  public func build() -> cryptography.MSSUIKitConfig
  @objc deinit
}
extension Swift.String {
  @inlinable public var bytesCryptoSwift: Swift.Array<Swift.UInt8> {
    get {
    data(using: String.Encoding.utf8, allowLossyConversion: true)?.bytesInCryptoSwift ?? Array(utf8)
  }
  }
  @inlinable public func md5() -> Swift.String {
    self.bytesCryptoSwift.md5().toHexString()
  }
  @inlinable public func sha1() -> Swift.String {
    self.bytesCryptoSwift.sha1().toHexString()
  }
  @inlinable public func sha224() -> Swift.String {
    self.bytesCryptoSwift.sha224().toHexString()
  }
  @inlinable public func sha256() -> Swift.String {
    self.bytesCryptoSwift.sha256().toHexString()
  }
  @inlinable public func sha384() -> Swift.String {
    self.bytesCryptoSwift.sha384().toHexString()
  }
  @inlinable public func sha512() -> Swift.String {
    self.bytesCryptoSwift.sha512().toHexString()
  }
  @inlinable public func sha3(_ variant: cryptography.CryptoSwiftSHA3.Variant) -> Swift.String {
    self.bytesCryptoSwift.sha3(variant).toHexString()
  }
  @inlinable public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String {
    self.bytesCryptoSwift.crc32(seed: seed, reflect: reflect).bytes().toHexString()
  }
  @inlinable public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String {
    self.bytesCryptoSwift.crc32c(seed: seed, reflect: reflect).bytes().toHexString()
  }
  @inlinable public func crc16(seed: Swift.UInt16? = nil) -> Swift.String {
    self.bytesCryptoSwift.crc16(seed: seed).bytes().toHexString()
  }
  @inlinable public func encrypt(cipher: any cryptography.CryptoSwiftCipher) throws -> Swift.String {
    try self.bytesCryptoSwift.encrypt(cipher: cipher).toHexString()
  }
  @inlinable public func encryptToBase64(cipher: any cryptography.CryptoSwiftCipher) throws -> Swift.String {
    try self.bytesCryptoSwift.encrypt(cipher: cipher).toBase64()
  }
  @inlinable public func authenticate<A>(with authenticator: A) throws -> Swift.String where A : cryptography.CryptoSwiftAuthenticator {
    try self.bytesCryptoSwift.authenticate(with: authenticator).toHexString()
  }
}
final public class CryptoSwiftPoly1305 : cryptography.CryptoSwiftAuthenticator {
  public enum CryptoSwiftError : Swift.Error {
    case authenticateError
    public static func == (a: cryptography.CryptoSwiftPoly1305.CryptoSwiftError, b: cryptography.CryptoSwiftPoly1305.CryptoSwiftError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
final public class CryptoSwiftAES {
  public enum Error : Swift.Error {
    case invalidKeySize
    case dataPaddingRequired
    case invalidData
    public static func == (a: cryptography.CryptoSwiftAES.Error, b: cryptography.CryptoSwiftAES.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Variant : Swift.Int {
    case aes128, aes192, aes256
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @usableFromInline
  final internal let variantNr: Swift.Int
  @usableFromInline
  final internal let variantNb: Swift.Int
  @usableFromInline
  final internal let variantNk: Swift.Int
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  final public let variant: cryptography.CryptoSwiftAES.Variant
  @usableFromInline
  final internal let blockMode: any cryptography.CryptoSwiftBlockMode
  @usableFromInline
  final internal let padding: cryptography.CryptoSwiftPadding
  @usableFromInline
  final internal var expandedKey: Swift.Array<Swift.Array<Swift.UInt32>> {
    get
    set
  }
  @usableFromInline
  final internal var expandedKeyInv: Swift.Array<Swift.Array<Swift.UInt32>> {
    get
    set
  }
  @usableFromInline
  internal static let T0: [Swift.UInt32]
  @usableFromInline
  internal static let T0_INV: [Swift.UInt32]
  @usableFromInline
  internal static let T1: [Swift.UInt32]
  @usableFromInline
  internal static let T1_INV: [Swift.UInt32]
  @usableFromInline
  internal static let T2: [Swift.UInt32]
  @usableFromInline
  internal static let T2_INV: [Swift.UInt32]
  @usableFromInline
  internal static let T3: [Swift.UInt32]
  @usableFromInline
  internal static let T3_INV: [Swift.UInt32]
  @usableFromInline
  internal static let U1: [Swift.UInt32]
  @usableFromInline
  internal static let U2: [Swift.UInt32]
  @usableFromInline
  internal static let U3: [Swift.UInt32]
  @usableFromInline
  internal static let U4: [Swift.UInt32]
  public init(key: Swift.Array<Swift.UInt8>, blockMode: any cryptography.CryptoSwiftBlockMode, padding: cryptography.CryptoSwiftPadding = .pkcs7) throws
  @inlinable final internal func encrypt(block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>? {
    if self.blockMode.options.contains(.paddingRequired) && block.count != CryptoSwiftAES.blockSize {
      return Array(block)
    }

    let rounds = self.variantNr
    let rk = self.expandedKey

    let b00 = UInt32(block[block.startIndex.advanced(by: 0)])
    let b01 = UInt32(block[block.startIndex.advanced(by: 1)]) << 8
    let b02 = UInt32(block[block.startIndex.advanced(by: 2)]) << 16
    let b03 = UInt32(block[block.startIndex.advanced(by: 3)]) << 24
    var b0 = b00 | b01 | b02 | b03

    let b10 = UInt32(block[block.startIndex.advanced(by: 4)])
    let b11 = UInt32(block[block.startIndex.advanced(by: 5)]) << 8
    let b12 = UInt32(block[block.startIndex.advanced(by: 6)]) << 16
    let b13 = UInt32(block[block.startIndex.advanced(by: 7)]) << 24
    var b1 = b10 | b11 | b12 | b13

    let b20 = UInt32(block[block.startIndex.advanced(by: 8)])
    let b21 = UInt32(block[block.startIndex.advanced(by: 9)]) << 8
    let b22 = UInt32(block[block.startIndex.advanced(by: 10)]) << 16
    let b23 = UInt32(block[block.startIndex.advanced(by: 11)]) << 24
    var b2 = b20 | b21 | b22 | b23

    let b30 = UInt32(block[block.startIndex.advanced(by: 12)])
    let b31 = UInt32(block[block.startIndex.advanced(by: 13)]) << 8
    let b32 = UInt32(block[block.startIndex.advanced(by: 14)]) << 16
    let b33 = UInt32(block[block.startIndex.advanced(by: 15)]) << 24
    var b3 = b30 | b31 | b32 | b33

    let tLength = 4
    let t = UnsafeMutablePointer<UInt32>.allocate(capacity: tLength)
    t.initialize(repeating: 0, count: tLength)
    defer {
      t.deinitialize(count: tLength)
      t.deallocate()
    }

    for r in 0..<rounds - 1 {
      t[0] = b0 ^ rk[r][0]
      t[1] = b1 ^ rk[r][1]
      t[2] = b2 ^ rk[r][2]
      t[3] = b3 ^ rk[r][3]

      let lb00 = CryptoSwiftAES.T0[Int(t[0] & 0xff)]
      let lb01 = CryptoSwiftAES.T1[Int((t[1] >> 8) & 0xff)]
      let lb02 = CryptoSwiftAES.T2[Int((t[2] >> 16) & 0xff)]
      let lb03 = CryptoSwiftAES.T3[Int(t[3] >> 24)]
      b0 = lb00 ^ lb01 ^ lb02 ^ lb03

      let lb10 = CryptoSwiftAES.T0[Int(t[1] & 0xff)]
      let lb11 = CryptoSwiftAES.T1[Int((t[2] >> 8) & 0xff)]
      let lb12 = CryptoSwiftAES.T2[Int((t[3] >> 16) & 0xff)]
      let lb13 = CryptoSwiftAES.T3[Int(t[0] >> 24)]
      b1 = lb10 ^ lb11 ^ lb12 ^ lb13

      let lb20 = CryptoSwiftAES.T0[Int(t[2] & 0xff)]
      let lb21 = CryptoSwiftAES.T1[Int((t[3] >> 8) & 0xff)]
      let lb22 = CryptoSwiftAES.T2[Int((t[0] >> 16) & 0xff)]
      let lb23 = CryptoSwiftAES.T3[Int(t[1] >> 24)]
      b2 = lb20 ^ lb21 ^ lb22 ^ lb23

      let lb30 = CryptoSwiftAES.T0[Int(t[3] & 0xff)]
      let lb31 = CryptoSwiftAES.T1[Int((t[0] >> 8) & 0xff)]
      let lb32 = CryptoSwiftAES.T2[Int((t[1] >> 16) & 0xff)]
      let lb33 = CryptoSwiftAES.T3[Int(t[2] >> 24)]
      b3 = lb30 ^ lb31 ^ lb32 ^ lb33
    }

    // last round
    let r = rounds - 1

    t[0] = b0 ^ rk[r][0]
    t[1] = b1 ^ rk[r][1]
    t[2] = b2 ^ rk[r][2]
    t[3] = b3 ^ rk[r][3]

    // rounds
    b0 = F1(t[0], t[1], t[2], t[3]) ^ rk[rounds][0]
    b1 = F1(t[1], t[2], t[3], t[0]) ^ rk[rounds][1]
    b2 = F1(t[2], t[3], t[0], t[1]) ^ rk[rounds][2]
    b3 = F1(t[3], t[0], t[1], t[2]) ^ rk[rounds][3]

    let encrypted: Array<UInt8> = [
      UInt8(b0 & 0xff), UInt8((b0 >> 8) & 0xff), UInt8((b0 >> 16) & 0xff), UInt8((b0 >> 24) & 0xff),
      UInt8(b1 & 0xff), UInt8((b1 >> 8) & 0xff), UInt8((b1 >> 16) & 0xff), UInt8((b1 >> 24) & 0xff),
      UInt8(b2 & 0xff), UInt8((b2 >> 8) & 0xff), UInt8((b2 >> 16) & 0xff), UInt8((b2 >> 24) & 0xff),
      UInt8(b3 & 0xff), UInt8((b3 >> 8) & 0xff), UInt8((b3 >> 16) & 0xff), UInt8((b3 >> 24) & 0xff)
    ]
    return encrypted
  }
  @usableFromInline
  final internal func decrypt(block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>?
  @objc deinit
}
extension cryptography.CryptoSwiftAES {
  @usableFromInline
  @inline(__always) final internal func F1(_ x0: Swift.UInt32, _ x1: Swift.UInt32, _ x2: Swift.UInt32, _ x3: Swift.UInt32) -> Swift.UInt32
}
extension cryptography.CryptoSwiftAES : cryptography.CryptoSwiftCipher {
  @inlinable final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    let blockSize = self.blockMode.customBlockSize ?? CryptoSwiftAES.blockSize
    let chunks = bytes.batched(by: blockSize)

    var oneTimeCryptor = try makeEncryptor()
    var out = Array<UInt8>(reserveCapacity: bytes.count)
    for chunk in chunks {
      out += try oneTimeCryptor.update(withBytes: chunk, isLast: false)
    }
    // Padding may be added at the very end
    out += try oneTimeCryptor.finish()

    if self.blockMode.options.contains(.paddingRequired) && (out.count % CryptoSwiftAES.blockSize != 0) {
      throw Error.dataPaddingRequired
    }

    return out
  }
  @inlinable final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    if self.blockMode.options.contains(.paddingRequired) && (bytes.count % CryptoSwiftAES.blockSize != 0) {
      throw Error.dataPaddingRequired
    }

    var oneTimeCryptor = try makeDecryptor()
    let chunks = bytes.batched(by: CryptoSwiftAES.blockSize)
    if chunks.isEmpty {
      throw Error.invalidData
    }

    var out = Array<UInt8>(reserveCapacity: bytes.count)

    var lastIdx = chunks.startIndex
    chunks.indices.formIndex(&lastIdx, offsetBy: chunks.count - 1)

    // To properly remove padding, `isLast` has to be known when called with the last chunk of ciphertext
    // Last chunk of ciphertext may contains padded data so next call to update(..) won't be able to remove it
    for idx in chunks.indices {
      out += try oneTimeCryptor.update(withBytes: chunks[idx], isLast: idx == lastIdx)
    }
    return out
  }
}
public struct MultipartForm : Swift.Hashable, Swift.Equatable {
  public struct Part : Swift.Hashable, Swift.Equatable {
    public var name: Swift.String
    public var data: Foundation.Data
    public var filename: Swift.String?
    public var contentType: Swift.String?
    public var value: Swift.String? {
      get
      set
    }
    public init(name: Swift.String, data: Foundation.Data, filename: Swift.String? = nil, contentType: Swift.String? = nil)
    public init(name: Swift.String, value: Swift.String)
    public func hash(into hasher: inout Swift.Hasher)
    public static func == (a: cryptography.MultipartForm.Part, b: cryptography.MultipartForm.Part) -> Swift.Bool
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum MultipartType : Swift.String {
    case formData
    case mixed
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public var boundary: Swift.String
  public var parts: [cryptography.MultipartForm.Part]
  public var multipartType: cryptography.MultipartForm.MultipartType
  public var contentType: Swift.String {
    get
  }
  public var bodyData: Foundation.Data {
    get
  }
  public init(parts: [cryptography.MultipartForm.Part] = [], boundary: Swift.String = UUID().uuidString, multipartType: cryptography.MultipartForm.MultipartType = .formData)
  public subscript(name: Swift.String) -> cryptography.MultipartForm.Part? {
    get
    set
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: cryptography.MultipartForm, b: cryptography.MultipartForm) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @objc(TransactionEntity) public class TransactionEntity : CoreData.NSManagedObject {
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  @objc deinit
}
public protocol MsauEkycProviderProtocol {
  func getEkycSetting(ekycUserInfo: cryptography.EkycUserInfo, customJwtToke: cryptography.EkycUserInfoCustomJwtToke?, completion: @escaping (Swift.Result<cryptography.EkycSetting, any Swift.Error>) -> Swift.Void)
  func sendEkycVideoFile(ekycVideoFile: cryptography.EkycVideoFile, customJwtToke: cryptography.EkycUserInfoCustomJwtToke?, completion: @escaping (cryptography.EkycResult) -> Swift.Void)
}
public enum ErrorType : Swift.Error {
  case compressionError
  case securityError
  case protocolError
  case serverError
  public static func == (a: cryptography.ErrorType, b: cryptography.ErrorType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct WSError : Swift.Error {
  public let type: cryptography.ErrorType
  public let message: Swift.String
  public let code: Swift.UInt16
  public init(type: cryptography.ErrorType, message: Swift.String, code: Swift.UInt16)
}
public protocol WebSocketClient : AnyObject {
  func connect()
  func disconnect(closeCode: Swift.UInt16)
  func write(string: Swift.String, completion: (() -> ())?)
  func write(stringData: Foundation.Data, completion: (() -> ())?)
  func write(data: Foundation.Data, completion: (() -> ())?)
  func write(ping: Foundation.Data, completion: (() -> ())?)
  func write(pong: Foundation.Data, completion: (() -> ())?)
}
extension cryptography.WebSocketClient {
  public func write(string: Swift.String)
  public func write(data: Foundation.Data)
  public func write(ping: Foundation.Data)
  public func write(pong: Foundation.Data)
  public func disconnect()
}
public enum WebSocketEvent {
  case connected([Swift.String : Swift.String])
  case disconnected(Swift.String, Swift.UInt16)
  case text(Swift.String)
  case binary(Foundation.Data)
  case pong(Foundation.Data?)
  case ping(Foundation.Data?)
  case error((any Swift.Error)?)
  case viabilityChanged(Swift.Bool)
  case reconnectSuggested(Swift.Bool)
  case cancelled
}
public protocol WebSocketDelegate : AnyObject {
  func didReceive(event: cryptography.WebSocketEvent, client: any cryptography.WebSocketClient)
}
open class WebSocket : cryptography.WebSocketClient, cryptography.EngineDelegate {
  weak public var delegate: (any cryptography.WebSocketDelegate)?
  public var onEvent: ((cryptography.WebSocketEvent) -> Swift.Void)?
  public var request: Foundation.URLRequest
  public var callbackQueue: Dispatch.DispatchQueue
  public var respondToPingWithPong: Swift.Bool {
    get
    set
  }
  public init(request: Foundation.URLRequest, engine: any cryptography.Engine)
  convenience public init(request: Foundation.URLRequest, certPinner: (any cryptography.CertificatePinning)? = FoundationSecurity(), compressionHandler: (any cryptography.CompressionHandler)? = nil, useCustomEngine: Swift.Bool = true)
  public func connect()
  public func disconnect(closeCode: Swift.UInt16 = CloseCode.normal.rawValue)
  public func forceDisconnect()
  public func write(data: Foundation.Data, completion: (() -> ())?)
  public func write(string: Swift.String, completion: (() -> ())?)
  public func write(stringData: Foundation.Data, completion: (() -> ())?)
  public func write(ping: Foundation.Data, completion: (() -> ())?)
  public func write(pong: Foundation.Data, completion: (() -> ())?)
  public func didReceive(event: cryptography.WebSocketEvent)
  @objc deinit
}
public enum SignMechanismEnum : Swift.String, Swift.Codable {
  case rsaX509
  case rsaPkcs1NoHash
  case rsaPkcs1Sha1
  case rsaPkcs1Sha256
  case rsaPkcs1Sha384
  case rsaPkcs1Sha512
  public var value: Swift.String {
    get
  }
  public var algo: Security.SecKeyAlgorithm {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers open class GCM {
  public static func crypt(_ opMode: cryptography.OpMode, algorithm: cryptography.Algorithm, data: Foundation.Data, key: Foundation.Data, iv: Foundation.Data, aData: Foundation.Data, tagLength: Swift.Int) throws -> (Foundation.Data, Foundation.Data)
  public static func available() -> Swift.Bool
  @objc deinit
}
public protocol FrameCollectorDelegate : AnyObject {
  func didForm(event: cryptography.FrameCollector.Event)
  func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
}
@_hasMissingDesignatedInitializers public class FrameCollector {
  public enum Event {
    case text(Swift.String)
    case binary(Foundation.Data)
    case pong(Foundation.Data?)
    case ping(Foundation.Data?)
    case error(any Swift.Error)
    case closed(Swift.String, Swift.UInt16)
  }
  public func add(frame: cryptography.Frame)
  @objc deinit
}
public struct IssueCertResultModel {
  public var transactionId: Swift.String?
  public var status: Swift.Bool
  public var step: cryptography.IssueCertStepResultModel
  public var date: Foundation.Date
  public var errorMessage: Swift.String?
  public init(transactionId: Swift.String?, status: Swift.Bool, step: cryptography.IssueCertStepResultModel, date: Foundation.Date, errorMessage: Swift.String? = nil)
}
public enum DHParam {
  case rfc3526Group5
  case rfc2409Group2
  public static func == (a: cryptography.DHParam, b: cryptography.DHParam) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class BaseRaEkycProvider : cryptography.MsauEkycProviderProtocol {
  public var ekyPath: Swift.String
  public init(providerName: Swift.String)
  public func getEkycSetting(ekycUserInfo: cryptography.EkycUserInfo, customJwtToke: cryptography.EkycUserInfoCustomJwtToke?, completion: @escaping (Swift.Result<cryptography.EkycSetting, any Swift.Error>) -> Swift.Void)
  public func sendEkycVideoFile(ekycVideoFile: cryptography.EkycVideoFile, customJwtToke: cryptography.EkycUserInfoCustomJwtToke?, completion: @escaping (cryptography.EkycResult) -> Swift.Void)
  @objc deinit
}
public struct PartRAGetCaptchaReqestModel : Swift.Codable {
  public var phoneNum: Swift.String
  public var nationalId: Swift.String
  public var birthYear: Swift.String
  public var birthMonth: Swift.String
  public var birthDayOfMonth: Swift.String
  public var cardSerialNum: Swift.String
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
public class CryptoSwiftCMAC : cryptography.CryptoSwiftAuthenticator {
  public enum Error : Swift.Error {
    case wrongKeyLength
    public static func == (a: cryptography.CryptoSwiftCMAC.Error, b: cryptography.CryptoSwiftCMAC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(key: Swift.Array<Swift.UInt8>) throws
  public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func authenticate(_ bytes: Swift.Array<Swift.UInt8>, cipher: any cryptography.CryptoSwiftCipher) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
public typealias ThrowableCallback = () throws -> Foundation.Data
public struct HeaderFieldModel {
}
@objc @_inheritsConvenienceInitializers public class HTTPRequestDelegate : ObjectiveC.NSObject, Foundation.URLSessionDelegate {
  @objc public func urlSession(_ session: Foundation.URLSession, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc override dynamic public init()
  @objc deinit
}
public enum SignModeEnum : Swift.String, Swift.Codable {
  case realTime
  case delayed
  case batch
  public var value: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum RegistrationBySignedMsisdnTypeView {
  case bottomSheet
  case singlePage
  public static func == (a: cryptography.RegistrationBySignedMsisdnTypeView, b: cryptography.RegistrationBySignedMsisdnTypeView) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension cryptography.Blowfish {
  convenience public init(key: Swift.String, iv: Swift.String, padding: cryptography.CryptoSwiftPadding = .pkcs7) throws
}
final public class CryptoSwiftSHA1 {
  @usableFromInline
  internal static let digestLength: Swift.Int
  @usableFromInline
  internal static let blockSize: Swift.Int
  @usableFromInline
  internal static let hashInitialValue: Swift.ContiguousArray<Swift.UInt32>
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var processedBytesTotalCount: Swift.Int
  @usableFromInline
  final internal var accumulatedHash: Swift.ContiguousArray<Swift.UInt32>
  public init()
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  @usableFromInline
  final internal func process(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.ContiguousArray<Swift.UInt32>)
  @objc deinit
}
extension cryptography.CryptoSwiftSHA1 : cryptography.CryptoSwiftUpdatable {
  @discardableResult
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      let lengthInBits = (processedBytesTotalCount + self.accumulated.count) * 8
      let lengthBytes = lengthInBits.bytes(totalBytes: 64 / 8) // A 64-bit representation of b

      // Step 1. Append padding
      bitPadding(to: &self.accumulated, blockSize: CryptoSwiftSHA1.blockSize, allowance: 64 / 8)

      // Step 2. Append Length a 64-bit representation of lengthInBits
      self.accumulated += lengthBytes
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: CryptoSwiftSHA1.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= CryptoSwiftSHA1.blockSize {
        self.process(block: chunk, currentHash: &self.accumulatedHash)
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)
    self.processedBytesTotalCount += processedBytes

    // output current hash
    var result = Array<UInt8>(repeating: 0, count: CryptoSwiftSHA1.digestLength)
    var pos = 0
    for idx in 0..<self.accumulatedHash.count {
      let h = self.accumulatedHash[idx]
      result[pos + 0] = UInt8((h >> 24) & 0xff)
      result[pos + 1] = UInt8((h >> 16) & 0xff)
      result[pos + 2] = UInt8((h >> 8) & 0xff)
      result[pos + 3] = UInt8(h & 0xff)
      pos += 4
    }

    // reset hash value for instance
    if isLast {
      self.accumulatedHash = CryptoSwiftSHA1.hashInitialValue
    }

    return result
  }
}
public enum OID : Swift.String {
  case etsiQcsCompliance
  case etsiQcsRetentionPeriod
  case etsiQcsQcSSCD
  case dsa
  case ecPublicKey
  case prime256v1
  case ecdsaWithSHA256
  case ecdsaWithSHA512
  case rsaEncryption
  case sha256WithRSAEncryption
  case md5WithRSAEncryption
  case sha1WithRSAEncryption
  case sha1
  case pkcsSha256
  case sha2Family
  case sha3_244
  case sha3_256
  case sha3_384
  case md5
  case pkcs7data
  case pkcs7signedData
  case pkcs7envelopedData
  case emailAddress
  case signingCertificateV2
  case contentType
  case messageDigest
  case signingTime
  case certificateExtension
  case jurisdictionLocalityName
  case jurisdictionStateOrProvinceName
  case jurisdictionCountryName
  case authorityInfoAccess
  case qcStatements
  case cps
  case unotice
  case serverAuth
  case clientAuth
  case ocsp
  case caIssuers
  case dateOfBirth
  case sha256
  case VeriSignEVpolicy
  case extendedValidation
  case organizationValidated
  case subjectKeyIdentifier
  case keyUsage
  case subjectAltName
  case issuerAltName
  case basicConstraints
  case cRLDistributionPoints
  case certificatePolicies
  case authorityKeyIdentifier
  case extKeyUsage
  case subjectDirectoryAttributes
  case commonName
  case surname
  case serialNumber
  case countryName
  case localityName
  case stateOrProvinceName
  case streetAddress
  case organizationName
  case organizationalUnitName
  case businessCategory
  case postalCode
  case givenName
  case dnQualifier
  case domainComponent
  case userId
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct CryptoSwiftPCBC : cryptography.CryptoSwiftBlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: cryptography.CryptoSwiftPCBC.Error, b: cryptography.CryptoSwiftPCBC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: cryptography.CryptoSwiftBlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping cryptography.CipherOperationOnBlock, encryptionOperation: @escaping cryptography.CipherOperationOnBlock) throws -> any cryptography.CryptoSwiftCipherModeWorker
}
public enum CertificateStatus : Swift.String, Swift.Codable {
  case notYetValid
  case expired
  case revoked
  case valid
  case suspend
  case unknown
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_specialize(exported: false, kind: full, where T == Swift.Int)
@_specialize(exported: false, kind: full, where T == Swift.UInt)
@_specialize(exported: false, kind: full, where T == Swift.UInt8)
@_specialize(exported: false, kind: full, where T == Swift.UInt16)
@_specialize(exported: false, kind: full, where T == Swift.UInt32)
@_specialize(exported: false, kind: full, where T == Swift.UInt64)
@inlinable internal func arrayOfBytes<T>(value: T, length totalBytes: Swift.Int = MemoryLayout<T>.size) -> Swift.Array<Swift.UInt8> where T : Swift.FixedWidthInteger {
  let valuePointer = UnsafeMutablePointer<T>.allocate(capacity: 1)
  valuePointer.pointee = value

  let bytesPointer = UnsafeMutablePointer<UInt8>(OpaquePointer(valuePointer))
  var bytes = Array<UInt8>(repeating: 0, count: totalBytes)
  for j in 0..<min(MemoryLayout<T>.size, totalBytes) {
    bytes[totalBytes - 1 - j] = (bytesPointer + j).pointee
  }

  valuePointer.deinitialize(count: 1)
  valuePointer.deallocate()

  return bytes
}
public enum PasswordPolicyType : Swift.String, Swift.Codable {
  case numeric
  case alphaNumeric
  case alphaNumeric_symbol
  case alphaNumeric_complex
  case alphaNumeric_symbol_complex
  public init(from decoder: any Swift.Decoder) throws
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public let MIN_MAX_REGULAR_EXPRESSION: Swift.String
public let NUMERIC_REGULAR_EXPRESSION: Swift.String
public let ALPHA_NUMERIC_REGULAR_EXPRESSION: Swift.String
public let ALPHA_NUMERIC_SYMBOL_REGULAR_EXPRESSION: Swift.String
public let ALPHA_NUMERIC_COMPLEX_REGULAR_EXPRESSION: Swift.String
public let ALPHA_NUMERIC_SYMBOL_COMPLEX_REGULAR_EXPRESSION: Swift.String
public enum MessageTypeEnum : Swift.String, Swift.Codable {
  case keyGeneration
  case sign
  case importCert
  case heartbeat
  case handshake
  public var value: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct CryptoSwiftHKDF {
  public enum Error : Swift.Error {
    case invalidInput
    case derivedKeyTooLong
    public static func == (a: cryptography.CryptoSwiftHKDF.Error, b: cryptography.CryptoSwiftHKDF.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>? = nil, info: Swift.Array<Swift.UInt8>? = nil, keyLength: Swift.Int? = nil, variant: cryptography.CryptoSwiftHMAC.Variant = .sha2(.sha256)) throws
  public func calculate() throws -> Swift.Array<Swift.UInt8>
}
extension cryptography.CryptoSwiftPKCS5 {
  public struct PBKDF2 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: cryptography.CryptoSwiftPKCS5.PBKDF2.Error, b: cryptography.CryptoSwiftPKCS5.PBKDF2.Error) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil, variant: cryptography.CryptoSwiftHMAC.Variant = .sha2(.sha256)) throws
    public func calculate() throws -> Swift.Array<Swift.UInt8>
  }
}
public enum RegisterType {
  case justRegister, registerToHome
  public static func == (a: cryptography.RegisterType, b: cryptography.RegisterType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol SimpleASN1Reading : AnyObject {
  func getReaderForContents() throws -> any cryptography.SimpleASN1Reading
  func getReaderForContents(identifiedBy expectedIdentifier: Swift.UInt8) throws -> any cryptography.SimpleASN1Reading
  func readContents() throws -> [Swift.UInt8]
  func readContents(identifiedBy expectedIdentifier: Swift.UInt8) throws -> [Swift.UInt8]
  func readContentsOfBitString() throws -> [Swift.UInt8]
  func skipComponent() throws
  func skipComponent(identifiedBy expectedIdentifier: Swift.UInt8) throws
  func skip(_ expectedBytes: [Swift.UInt8]) throws
  func unwrap() throws
  func unwrap(expectedIdentifier: Swift.UInt8) throws
  func peek() throws -> Swift.UInt8
}
extension cryptography.CryptoSwiftHMAC {
  convenience public init(key: Swift.String, variant: cryptography.CryptoSwiftHMAC.Variant = .md5) throws
}
extension Swift.UInt64 {
  @_specialize(exported: false, kind: full, where T == Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init<T>(bytes: T, fromIndex index: T.Index) where T : Swift.Collection, T.Element == Swift.UInt8, T.Index == Swift.Int {
    if bytes.isEmpty {
      self = 0
      return
    }

    let count = bytes.count

    let val0 = count > 0 ? UInt64(bytes[index.advanced(by: 0)]) << 56 : 0
    let val1 = count > 1 ? UInt64(bytes[index.advanced(by: 1)]) << 48 : 0
    let val2 = count > 2 ? UInt64(bytes[index.advanced(by: 2)]) << 40 : 0
    let val3 = count > 3 ? UInt64(bytes[index.advanced(by: 3)]) << 32 : 0
    let val4 = count > 4 ? UInt64(bytes[index.advanced(by: 4)]) << 24 : 0
    let val5 = count > 5 ? UInt64(bytes[index.advanced(by: 5)]) << 16 : 0
    let val6 = count > 6 ? UInt64(bytes[index.advanced(by: 6)]) << 8 : 0
    let val7 = count > 7 ? UInt64(bytes[index.advanced(by: 7)]) : 0

    self = val0 | val1 | val2 | val3 | val4 | val5 | val6 | val7
  }
}
@_hasMissingDesignatedInitializers public class ASN1DERDecoder {
  public static func decode(data: Foundation.Data) throws -> [cryptography.ASN1Object]
  @objc deinit
}
extension Foundation.Data {
  public var uint64Value: Swift.UInt64? {
    get
  }
}
extension Foundation.Data {
  public var sequenceContent: Foundation.Data {
    get
  }
}
@_hasMissingDesignatedInitializers public class X509Certificate : Swift.CustomStringConvertible {
  convenience public init(data: Foundation.Data) throws
  public init(der: Foundation.Data) throws
  convenience public init(pem: Foundation.Data) throws
  public var description: Swift.String {
    get
  }
  public func checkValidity(_ date: Foundation.Date = Date()) -> Swift.Bool
  public var version: Swift.Int? {
    get
  }
  public var serialNumber: Foundation.Data? {
    get
  }
  public var issuerDistinguishedName: Swift.String? {
    get
  }
  public var issuerOIDs: [Swift.String] {
    get
  }
  public func issuer(oidString: Swift.String) -> Swift.String?
  public func issuer(oid: cryptography.OID) -> Swift.String?
  @available(*, deprecated, message: "Use issuer(oid:) instead")
  public func issuer(dn: cryptography.ASN1DistinguishedNames) -> Swift.String?
  public var subjectDistinguishedName: Swift.String? {
    get
  }
  public var subjectOIDs: [Swift.String] {
    get
  }
  public func subject(oidString: Swift.String) -> [Swift.String]?
  public func subject(oid: cryptography.OID) -> [Swift.String]?
  @available(*, deprecated, message: "Use subject(oid:) instead")
  public func subject(dn: cryptography.ASN1DistinguishedNames) -> [Swift.String]?
  public var notBefore: Foundation.Date? {
    get
  }
  public var notAfter: Foundation.Date? {
    get
  }
  public var signature: Foundation.Data? {
    get
  }
  public var sigAlgName: Swift.String? {
    get
  }
  public var sigAlgOID: Swift.String? {
    get
  }
  public var sigAlgParams: Foundation.Data? {
    get
  }
  public var keyUsage: [Swift.Bool] {
    get
  }
  public var extendedKeyUsage: [Swift.String] {
    get
  }
  public var subjectAlternativeNames: [Swift.String] {
    get
  }
  public var issuerAlternativeNames: [Swift.String] {
    get
  }
  public var publicKey: cryptography.X509PublicKey? {
    get
  }
  public var publicKeyPEM: Swift.String? {
    get
  }
  public func toPEM(_ derKey: Foundation.Data) -> Swift.String
  public func base64Decode(_ base64Data: Swift.String) -> Foundation.Data?
  public func base64Encode(_ key: Foundation.Data) -> Swift.String
  public var criticalExtensionOIDs: [Swift.String] {
    get
  }
  public var nonCriticalExtensionOIDs: [Swift.String] {
    get
  }
  public func extensionObject(oid: cryptography.OID) -> cryptography.X509Extension?
  public func extensionObject(oid: Swift.String) -> cryptography.X509Extension?
  @objc deinit
}
extension cryptography.ArchivedTransactionEntity {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<cryptography.ArchivedTransactionEntity>
  @objc @NSManaged dynamic public var clientAcknowledgmentContent: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var creationDate: Foundation.Date? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var lastUpdateDate: Foundation.Date? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var messageId: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var messageType: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var metaData: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var pdfFileContent: Foundation.Data? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var serverSolicitationContent: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var transactionResultStatus: Swift.String? {
    @objc get
    @objc set
  }
}
final public class CryptoSwiftScrypt {
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, dkLen: Swift.Int, N: Swift.Int, r: Swift.Int, p: Swift.Int) throws
  final public func calculate() throws -> [Swift.UInt8]
  @objc deinit
}
public enum HMACAlg : cryptography.CC.CCHmacAlgorithm {
  case sha1, md5, sha256, sha384, sha512, sha224
  public init?(rawValue: cryptography.CC.CCHmacAlgorithm)
  public typealias RawValue = cryptography.CC.CCHmacAlgorithm
  public var rawValue: cryptography.CC.CCHmacAlgorithm {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class DashedView : UIKit.UIView {
  public struct Configuration {
    public var color: UIKit.UIColor
    public var dashLength: CoreFoundation.CGFloat
    public var dashGap: CoreFoundation.CGFloat
    public init(color: UIKit.UIColor, dashLength: CoreFoundation.CGFloat, dashGap: CoreFoundation.CGFloat)
  }
  @_Concurrency.MainActor(unsafe) public class var lineHeight: CoreFoundation.CGFloat {
    get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) final public var config: cryptography.DashedView.Configuration {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
public struct InitializeStatus {
  public var isAvailable: Swift.Bool
  public var error: cryptography.MSAU.CustomError?
  public init(isAvailable: Swift.Bool, error: cryptography.MSAU.CustomError?)
}
public struct PersianDatePickerPresenter {
  public init()
  public func show(view: UIKit.UIView, callBack: @escaping (_ persianDate: Swift.String) -> ())
  public func show1(in viewController: UIKit.UIViewController, callBack: @escaping (_ persianDate: Swift.String) -> ())
}
public enum PopUpTypeView {
  case bottomSheet
  case dialog
  public static func == (a: cryptography.PopUpTypeView, b: cryptography.PopUpTypeView) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum OpMode : cryptography.CC.CCOperation {
  case encrypt, decrypt
  public init?(rawValue: cryptography.CC.CCOperation)
  public typealias RawValue = cryptography.CC.CCOperation
  public var rawValue: cryptography.CC.CCOperation {
    get
  }
}
public enum MultiPartResult<Value, ResponseError> where ResponseError : cryptography.GeneralResponseModel {
  case success(Value)
  case failure(ResponseError)
  case error((any Swift.Error)?)
}
@objc @_inheritsConvenienceInitializers public class MultiPart : ObjectiveC.NSObject {
  public static let fieldName: Swift.String
  public static let pathURLs: Swift.String
  public func callPostWebService(_ url_String: Swift.String, parameetrs: [Swift.String : Any]?, filePathArr arrFilePath: [[Swift.String : Any]]?, completion: @escaping ([Swift.String : Any]?, (any Swift.Error)?) -> ())
  public func callPostWSWithModel<T>(_ url_String: Swift.String, parameters: [Swift.String : Any]?, filePathArr arrFilePath: [[Swift.String : Any]]?, model: T.Type, completion: @escaping (cryptography.MultiPartResult<T, cryptography.GeneralResponseModel>) -> ()) where T : Swift.Decodable
  @objc override dynamic public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers public class GeneralResponseModel : Swift.Decodable {
  @objc deinit
  required public init(from decoder: any Swift.Decoder) throws
}
@_inheritsConvenienceInitializers @objc open class NFXProtocol : Foundation.URLProtocol {
  @objc override dynamic open class func canInit(with request: Foundation.URLRequest) -> Swift.Bool
  @objc override dynamic open class func canInit(with task: Foundation.URLSessionTask) -> Swift.Bool
  @objc override dynamic open func startLoading()
  @objc override dynamic open func stopLoading()
  @objc override dynamic open class func canonicalRequest(for request: Foundation.URLRequest) -> Foundation.URLRequest
  @objc override dynamic public init(request: Foundation.URLRequest, cachedResponse: Foundation.CachedURLResponse?, client: (any Foundation.URLProtocolClient)?)
  @objc deinit
}
extension cryptography.NFXProtocol : Foundation.URLSessionDataDelegate {
  @objc dynamic public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  @objc dynamic public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive response: Foundation.URLResponse, completionHandler: @escaping (Foundation.URLSession.ResponseDisposition) -> Swift.Void)
  @objc dynamic public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: (any Swift.Error)?)
  @objc dynamic public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
  @objc dynamic public func urlSession(_ session: Foundation.URLSession, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic public func urlSessionDidFinishEvents(forBackgroundURLSession session: Foundation.URLSession)
}
final public class SimpleASN1Writer : cryptography.SimpleASN1Writing {
  final public var encoding: [Swift.UInt8] {
    get
  }
  public init()
  final public func write(from writer: cryptography.SimpleASN1Writer)
  final public func write(_ bytes: [Swift.UInt8])
  final public func write(_ contents: [Swift.UInt8], identifiedBy identifier: Swift.UInt8)
  final public func wrap(with identifier: Swift.UInt8)
  final public func wrapBitString()
  @objc deinit
}
public enum TCPTransportError : Swift.Error {
  case invalidRequest
  public static func == (a: cryptography.TCPTransportError, b: cryptography.TCPTransportError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public class TCPTransport : cryptography.Transport {
  public var usingTLS: Swift.Bool {
    get
  }
  public init(connection: Network.NWConnection)
  public init()
  public func connect(url: Foundation.URL, timeout: Swift.Double = 10, certificatePinning: (any cryptography.CertificatePinning)? = nil)
  public func disconnect()
  public func register(delegate: any cryptography.TransportEventClient)
  public func write(data: Foundation.Data, completion: @escaping (((any Swift.Error)?) -> ()))
  @objc deinit
}
public enum CipherError : Swift.Error {
  case encrypt
  case decrypt
  public static func == (a: cryptography.CipherError, b: cryptography.CipherError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol CryptoSwiftCipher : AnyObject {
  var keySize: Swift.Int { get }
  func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension cryptography.CryptoSwiftCipher {
  public func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension Swift.String {
  public func decryptBase64ToString(cipher: any cryptography.CryptoSwiftCipher) throws -> Swift.String
  public func decryptBase64(cipher: any cryptography.CryptoSwiftCipher) throws -> Swift.Array<Swift.UInt8>
}
extension cryptography.PKCS7 {
  public var signatures: [cryptography.SignatureInfo]? {
    get
  }
}
public class SignatureInfo {
  final public let version: cryptography.ASN1Object?
  final public let signerIdentifier: cryptography.ASN1Object?
  final public let digestAlgorithmIdentifier: cryptography.ASN1Object?
  final public let signedAttributes: cryptography.ASN1Object?
  final public let signatureAlgorithm: cryptography.ASN1Object?
  final public let signature: cryptography.ASN1Object?
  public var signatureData: Foundation.Data? {
    get
  }
  public var disgestAlgorithmName: Swift.String? {
    get
  }
  public var digestAlgorithmOID: cryptography.OID? {
    get
  }
  public var signatureAlgorithmName: Swift.String? {
    get
  }
  public var signatureAlgorithmOID: cryptography.OID? {
    get
  }
  public init(asn1: cryptography.ASN1Object)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class FoundationHTTPServerHandler : cryptography.HTTPServerHandler {
  public func register(delegate: any cryptography.HTTPServerDelegate)
  public func createResponse(headers: [Swift.String : Swift.String]) -> Foundation.Data
  public func parse(data: Foundation.Data)
  @objc deinit
}
public typealias CipherOperationOnBlock = (_ block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>?
public protocol CryptoSwiftBlockMode {
  var options: cryptography.CryptoSwiftBlockModeOption { get }
  @inlinable func worker(blockSize: Swift.Int, cipherOperation: @escaping cryptography.CipherOperationOnBlock, encryptionOperation: @escaping cryptography.CipherOperationOnBlock) throws -> any cryptography.CryptoSwiftCipherModeWorker
  var customBlockSize: Swift.Int? { get }
}
@_hasMissingDesignatedInitializers open class CRC {
  public typealias CNcrc = Swift.UInt32
  public enum Mode : cryptography.CRC.CNcrc {
    case crc8, crc8ICODE, crc8ITU, crc8ROHC, crc8WCDMA, crc16, crc16CCITTTrue, crc16CCITTFalse, crc16USB, crc16XMODEM, crc16DECTR, crc16DECTX, crc16ICODE, crc16VERIFONE, crc16A, crc16B, crc16Fletcher, crc32Adler, crc32, crc32CASTAGNOLI, crc32BZIP2, crc32MPEG2, crc32POSIX, crc32XFER, crc64ECMA182
    public init?(rawValue: cryptography.CRC.CNcrc)
    public typealias RawValue = cryptography.CRC.CNcrc
    public var rawValue: cryptography.CRC.CNcrc {
      get
    }
  }
  public static func crc(_ input: Foundation.Data, mode: cryptography.CRC.Mode) throws -> Swift.UInt64
  public static func available() -> Swift.Bool
  @objc deinit
}
@usableFromInline
final internal class CryptoSwiftStreamDecryptor : cryptography.CryptoSwiftCryptor, cryptography.CryptoSwiftUpdatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal var worker: any cryptography.CryptoSwiftCipherModeWorker
  @usableFromInline
  final internal let padding: cryptography.CryptoSwiftPadding
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var lastBlockRemainder: Swift.Int
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: cryptography.CryptoSwiftPadding, _ worker: any cryptography.CryptoSwiftCipherModeWorker) throws
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    let toProcess = self.accumulated.prefix(max(self.accumulated.count - self.worker.additionalBufferSize, 0))

    if var finalizingWorker = worker as? CryptoSwiftFinalizingDecryptModeWorker, isLast == true {
      // will truncate suffix if needed
      try finalizingWorker.willDecryptLast(bytes: self.accumulated.slice)
    }

    var processedBytesCount = 0
    var plaintext = Array<UInt8>(reserveCapacity: bytes.count + self.worker.additionalBufferSize)
    for chunk in toProcess.batched(by: self.blockSize) {
      plaintext += self.worker.decrypt(block: chunk)
      processedBytesCount += chunk.count
    }

    if var finalizingWorker = worker as? CryptoSwiftFinalizingDecryptModeWorker, isLast == true {
      plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
    }

    // omit unecessary calculation if not needed
    if self.padding != .noPadding {
      self.lastBlockRemainder = plaintext.count.quotientAndRemainder(dividingBy: self.blockSize).remainder
    }

    if isLast {
      // CTR doesn't need padding. Really. Add padding to the last block if really want. but... don't.
      plaintext = self.padding.remove(from: plaintext, blockSize: self.blockSize - self.lastBlockRemainder)
    }

    self.accumulated.removeFirst(processedBytesCount) // super-slow

    if var finalizingWorker = worker as? CryptoSwiftFinalizingDecryptModeWorker, isLast == true {
      plaintext = Array(try finalizingWorker.finalize(decrypt: plaintext.slice))
    }

    return plaintext
  }
  @inlinable final public func seek(to position: Swift.Int) throws {
    guard var worker = self.worker as? CryptoSwiftSeekableModeWorker else {
      fatalError("Not supported")
    }

    try worker.seek(to: position)
    self.worker = worker
  }
  @objc @usableFromInline
  deinit
}
@_hasMissingDesignatedInitializers open class PKCS8PrivateKey {
  public static func getPKCS1DEROffset(_ derKey: Foundation.Data) -> Swift.Int?
  public static func stripHeaderIfAny(_ derKey: Foundation.Data) -> Foundation.Data?
  public static func hasCorrectHeader(_ derKey: Foundation.Data) -> Swift.Bool
  @objc deinit
}
public class SecurityAPI {
  public init()
  public func generateKeys(type: cryptography.KeyTypeEnum) -> (publicKey: Swift.String, modulus: Swift.String, exponent: Swift.String, keyAlias: Swift.String)
  public func generateAndReturnKeys(type: cryptography.KeyTypeEnum) -> (publicKeyAsEncodedBase64: Swift.String, publicKeyAsData: Foundation.Data, privateKeyAsString: Swift.String, privateKeyAsData: Foundation.Data, modulus: Swift.String, exponent: Swift.String, keyTag: Swift.String)
  public func sign(keyId: Swift.String, dtbsContent: Swift.String, signitureType: cryptography.SignMechanismEnum, privateKey: Foundation.Data, keyLengthBits: Swift.Int) throws -> Foundation.Data
  public func sign1(keyAlias: Swift.String, data: Foundation.Data, signitureType: cryptography.SignMechanismEnum) -> Foundation.Data?
  public func aesGcmIvDecrypt(data: Foundation.Data, iv: [Swift.UInt8], key: Foundation.Data) -> Swift.String?
  public func aesGcmIvZeroDecrypt(data: Foundation.Data, key: Foundation.Data) -> Swift.String?
  public func aesGcmIvEncrypt(data: Foundation.Data, iv: [Swift.UInt8], key: Foundation.Data) -> Swift.String?
  public func aesGcmIvZeroEncrypt(data: Foundation.Data, key: Foundation.Data) -> Swift.String?
  public func aesEncryptDecryptTemp(data: Foundation.Data, key: Foundation.Data) -> Swift.String?
  public func aesDecryptTemp3(data: Foundation.Data, passwordContent: Swift.String, saltContent: Swift.String) -> Swift.String?
  public func aesDecryptTemp1(data: Foundation.Data, withKey AES_KEY: Foundation.Data) -> Swift.String?
  public func signByHmacAsBase64EncodedString(data: Swift.String, keyHMAC: Foundation.Data) -> Swift.String?
  @objc deinit
}
@_hasMissingDesignatedInitializers open class PEMPublicKey {
  public static func toDER(_ pemKey: Swift.String) throws -> Foundation.Data
  public static func toPEM(_ derKey: Foundation.Data) -> Swift.String
  public static func addHeader(_ base64: Swift.String) -> Swift.String
  @objc deinit
}
public struct DeleteKeyResponse : Swift.Codable {
  public func encode(to encoder: any Swift.Encoder) throws
  public init(from decoder: any Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers open class PEMPrivateKey {
  public static func toDER(_ pemKey: Swift.String) throws -> Foundation.Data
  public static func toPEM(_ derKey: Foundation.Data) -> Swift.String
  public static func addHeader(_ base64: Swift.String) -> Swift.String
  public static func addRSAHeader(_ base64: Swift.String) -> Swift.String
  public static func stripHeader(_ pemKey: Swift.String) -> Swift.String?
  @objc deinit
}
final public class ActivityData {
  public init(size: CoreFoundation.CGSize? = nil, message: Swift.String? = nil, messageFont: UIKit.UIFont? = nil, messageSpacing: CoreFoundation.CGFloat? = nil, type: cryptography.LaodingIndicatorType? = nil, color: UIKit.UIColor? = nil, padding: CoreFoundation.CGFloat? = nil, displayTimeThreshold: Swift.Int? = nil, minimumDisplayTime: Swift.Int? = nil, backgroundColor: UIKit.UIColor? = nil, textColor: UIKit.UIColor? = nil)
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class NVActivityIndicatorPresenter {
  public static let sharedInstance: cryptography.NVActivityIndicatorPresenter
  final public var isAnimating: Swift.Bool {
    get
  }
  final public func startAnimating(_ data: cryptography.ActivityData, _ fadeInAnimation: cryptography.FadeInAnimation? = nil)
  final public func stopAnimating(_ fadeOutAnimation: cryptography.FadeOutAnimation? = nil)
  final public func setMessage(_ message: Swift.String?)
  @objc deinit
}
public enum IssueCertParentType {
  case homeInSdk, supperApp
  public static func == (a: cryptography.IssueCertParentType, b: cryptography.IssueCertParentType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@usableFromInline
final internal class CryptoSwiftStreamEncryptor : cryptography.CryptoSwiftCryptor, cryptography.CryptoSwiftUpdatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal var worker: any cryptography.CryptoSwiftCipherModeWorker
  @usableFromInline
  final internal let padding: cryptography.CryptoSwiftPadding
  @usableFromInline
  final internal var lastBlockRemainder: Swift.Int
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: cryptography.CryptoSwiftPadding, _ worker: any cryptography.CryptoSwiftCipherModeWorker) throws
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8> {
    var accumulated = Array(bytes)
    if isLast {
      // CTR doesn't need padding. Really. Add padding to the last block if really want. but... don't.
      accumulated = self.padding.add(to: accumulated, blockSize: self.blockSize - self.lastBlockRemainder)
    }

    var encrypted = Array<UInt8>(reserveCapacity: bytes.count)
    for chunk in accumulated.batched(by: self.blockSize) {
      encrypted += self.worker.encrypt(block: chunk)
    }

    // omit unecessary calculation if not needed
    if self.padding != .noPadding {
      self.lastBlockRemainder = encrypted.count.quotientAndRemainder(dividingBy: self.blockSize).remainder
    }

    if var finalizingWorker = worker as? CryptoSwiftFinalizingEncryptModeWorker, isLast == true {
      encrypted = Array(try finalizingWorker.finalize(encrypt: encrypted.slice))
    }

    return encrypted
  }
  @usableFromInline
  final internal func seek(to: Swift.Int) throws
  @objc @usableFromInline
  deinit
}
extension Swift.UInt32 {
  @_specialize(exported: false, kind: full, where T == Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init<T>(bytes: T, fromIndex index: T.Index) where T : Swift.Collection, T.Element == Swift.UInt8, T.Index == Swift.Int {
    if bytes.isEmpty {
      self = 0
      return
    }

    let count = bytes.count

    let val0 = count > 0 ? UInt32(bytes[index.advanced(by: 0)]) << 24 : 0
    let val1 = count > 1 ? UInt32(bytes[index.advanced(by: 1)]) << 16 : 0
    let val2 = count > 2 ? UInt32(bytes[index.advanced(by: 2)]) << 8 : 0
    let val3 = count > 3 ? UInt32(bytes[index.advanced(by: 3)]) : 0

    self = val0 | val1 | val2 | val3
  }
}
public struct CryptoSwiftBlockModeOption : Swift.OptionSet {
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  @usableFromInline
  internal static let none: cryptography.CryptoSwiftBlockModeOption
  @usableFromInline
  internal static let initializationVectorRequired: cryptography.CryptoSwiftBlockModeOption
  @usableFromInline
  internal static let paddingRequired: cryptography.CryptoSwiftBlockModeOption
  @usableFromInline
  internal static let useEncryptToDecrypt: cryptography.CryptoSwiftBlockModeOption
  public typealias ArrayLiteralElement = cryptography.CryptoSwiftBlockModeOption
  public typealias Element = cryptography.CryptoSwiftBlockModeOption
  public typealias RawValue = Swift.Int
}
public enum Padding : cryptography.CC.CCPadding {
  case noPadding, pkcs7Padding
  public init?(rawValue: cryptography.CC.CCPadding)
  public typealias RawValue = cryptography.CC.CCPadding
  public var rawValue: cryptography.CC.CCPadding {
    get
  }
}
@_hasMissingDesignatedInitializers open class CMAC {
  public static func AESCMAC(_ data: Foundation.Data, key: Foundation.Data) -> Foundation.Data
  public static func available() -> Swift.Bool
  @objc deinit
}
public enum CustomAlertControllerShadowStyle {
  case leftBottom
  case rightBottom
  case leftTop
  case rightTop
  public static func == (a: cryptography.CustomAlertControllerShadowStyle, b: cryptography.CustomAlertControllerShadowStyle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class CustomAlertControllerAlert : UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) public func setContentAttribute(title: Swift.String? = nil, titleColor: UIKit.UIColor = .black, message: Swift.String? = nil, messageColor: UIKit.UIColor = .black, backgroundColor: UIKit.UIColor = .white, icon: UIKit.UIImage? = nil)
  @_Concurrency.MainActor(unsafe) public func addButton(title: Swift.String, titleColor: UIKit.UIColor, backgroundColor: UIKit.UIColor, action: (() -> ())?)
  @_Concurrency.MainActor(unsafe) public func setContentShadowDirection(style: cryptography.CustomAlertControllerShadowStyle)
  @objc deinit
}
extension cryptography.CustomAlertControllerAlert : UIKit.UIGestureRecognizerDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldReceive touch: UIKit.UITouch) -> Swift.Bool
}
public protocol CryptoSwiftAuthenticator {
  func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
@available(watchOS, unavailable)
public class WebSocketServer : cryptography.Server, cryptography.ConnectionDelegate {
  public var onEvent: ((cryptography.ServerEvent) -> Swift.Void)?
  public init()
  public func start(address: Swift.String, port: Swift.UInt16) -> (any Swift.Error)?
  public func didReceive(event: cryptography.ServerEvent)
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public class ServerConnection : cryptography.Connection, cryptography.HTTPServerDelegate, cryptography.FramerEventClient, cryptography.FrameCollectorDelegate, cryptography.TransportEventClient {
  public var onEvent: ((cryptography.ConnectionEvent) -> Swift.Void)?
  weak public var delegate: (any cryptography.ConnectionDelegate)?
  public func write(data: Foundation.Data, opcode: cryptography.FrameOpCode)
  public func connectionChanged(state: cryptography.ConnectionState)
  public func didReceive(event: cryptography.HTTPEvent)
  public func frameProcessed(event: cryptography.FrameEvent)
  public func didForm(event: cryptography.FrameCollector.Event)
  public func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  @objc deinit
}
@available(*, renamed: "Digest")
public typealias CryptoSwiftHash = cryptography.CryptoSwiftDigest
public struct CryptoSwiftDigest {
  public static func md5(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha1(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha224(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha256(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha384(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha512(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha2(_ bytes: Swift.Array<Swift.UInt8>, variant: cryptography.CryptoSwiftSHA2.Variant) -> Swift.Array<Swift.UInt8>
  public static func sha3(_ bytes: Swift.Array<Swift.UInt8>, variant: cryptography.CryptoSwiftSHA3.Variant) -> Swift.Array<Swift.UInt8>
}
public enum Algorithm : cryptography.CC.CCAlgorithm {
  case aes, des, threeDES, cast, rc4, rc2, blowfish
  public init?(rawValue: cryptography.CC.CCAlgorithm)
  public typealias RawValue = cryptography.CC.CCAlgorithm
  public var rawValue: cryptography.CC.CCAlgorithm {
    get
  }
}
public struct RSAPublicKeyExporter : cryptography.RSAPublicKeyExporting {
  public let sequenceIdentifier: Swift.UInt8
  public init()
  public func toSubjectPublicKeyInfo(_ rsaPublicKey: Foundation.Data) -> Foundation.Data
}
public enum IssueCertTransactionStatus : Swift.String, Swift.Codable {
  case PAY_REQUIRED
  case PAYMENT_DONE
  case INITIAL
  case KEY_GENERATED
  case CSR_SIGNED
  case CERT_CREATED
  case CERT_IMPORTED
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@_inheritsConvenienceInitializers @objc open class NFX : ObjectiveC.NSObject {
  @objc open class func sharedInstance() -> cryptography.NFX
  @objc public enum ENFXGesture : Swift.Int {
    case shake
    case custom
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @objc open func start()
  @objc open func stop()
  @objc open func isStarted() -> Swift.Bool
  @objc open func setCachePolicy(_ policy: Foundation.URLCache.StoragePolicy)
  @objc open func setGesture(_ gesture: cryptography.NFX.ENFXGesture)
  @objc open func show()
  @objc open func hide()
  @objc open func toggle()
  @objc open func ignoreURL(_ url: Swift.String)
  @objc open func getSessionLog() -> Foundation.Data?
  @objc open func ignoreURLs(_ urls: [Swift.String])
  @objc open func ignoreURLsWithRegex(_ regex: Swift.String)
  @objc open func ignoreURLsWithRegexes(_ regexes: [Swift.String])
  @objc override dynamic public init()
  @objc deinit
}
extension cryptography.NFX : UIKit.UIAdaptivePresentationControllerDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func presentationControllerDidDismiss(_ presentationController: UIKit.UIPresentationController)
}
public protocol LoadingIndicatorViewable {
}
extension cryptography.LoadingIndicatorViewable where Self : UIKit.UIViewController {
  public var isAnimating: Swift.Bool {
    get
  }
  public func startAnimating(_ size: CoreFoundation.CGSize? = nil, message: Swift.String? = nil, messageFont: UIKit.UIFont? = nil, type: cryptography.LaodingIndicatorType? = nil, color: UIKit.UIColor? = nil, padding: CoreFoundation.CGFloat? = nil, displayTimeThreshold: Swift.Int? = nil, minimumDisplayTime: Swift.Int? = nil, backgroundColor: UIKit.UIColor? = nil, textColor: UIKit.UIColor? = nil, fadeInAnimation: cryptography.FadeInAnimation? = NVActivityIndicatorView.DEFAULT_FADE_IN_ANIMATION)
  public func stopAnimating(_ fadeOutAnimation: cryptography.FadeOutAnimation? = NVActivityIndicatorView.DEFAULT_FADE_OUT_ANIMATION)
}
public enum AuthBlockMode : cryptography.CC.CCMode {
  case gcm, ccm
  public init?(rawValue: cryptography.CC.CCMode)
  public typealias RawValue = cryptography.CC.CCMode
  public var rawValue: cryptography.CC.CCMode {
    get
  }
}
public struct CryptoSwiftCCM {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case invalidParameter
    case fail
    public static func == (a: cryptography.CryptoSwiftCCM.Error, b: cryptography.CryptoSwiftCCM.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: cryptography.CryptoSwiftBlockModeOption
  public let customBlockSize: Swift.Int?
  public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping cryptography.CipherOperationOnBlock, encryptionOperation: @escaping cryptography.CipherOperationOnBlock) throws -> any cryptography.CryptoSwiftCipherModeWorker
}
@objc @_inheritsConvenienceInitializers @IBDesignable @_Concurrency.MainActor(unsafe) public class PersianDatePickerView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public var year: Swift.Int
  @_Concurrency.MainActor(unsafe) public var month: Swift.Int
  @_Concurrency.MainActor(unsafe) public var day: Swift.Int
  @_Concurrency.MainActor(unsafe) public var onChange: (cryptography.Listener)?
  @_Concurrency.MainActor(unsafe) public var font: UIKit.UIFont?
  @_Concurrency.MainActor(unsafe) public var style: cryptography.PersianDatePickerStyle {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) convenience public init(date: Foundation.Date, timeZone: Foundation.TimeZone? = nil)
  @_Concurrency.MainActor(unsafe) public func setYearsRange(fromYear: Swift.Int, toYear: Swift.Int)
  @_Concurrency.MainActor(unsafe) public func setMaxYear(toYear: Swift.Int)
  @_Concurrency.MainActor(unsafe) public func setMinYear(fromYear: Swift.Int)
  @_Concurrency.MainActor(unsafe) public func gotoDefualtDate()
  @_Concurrency.MainActor(unsafe) public func gotoCurrentDate()
  @_Concurrency.MainActor(unsafe) public func gotoDate(date: Foundation.Date)
  @_Concurrency.MainActor(unsafe) public func setPersianDate(year: Swift.Int, month: Swift.Int, day: Swift.Int)
  @_Concurrency.MainActor(unsafe) public func getGregorianDate() -> Foundation.Date?
  @_Concurrency.MainActor(unsafe) public func getPersianDate() -> Swift.String?
  @_Concurrency.MainActor(unsafe) public func nextDay(by date: Swift.String)
  @_Concurrency.MainActor(unsafe) public func backDay(by date: Swift.String)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func layoutSubviews()
  @objc deinit
}
extension cryptography.PersianDatePickerView : UIKit.UIPickerViewDataSource {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func numberOfComponents(in pickerView: UIKit.UIPickerView) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc dynamic public func pickerView(_ pickerView: UIKit.UIPickerView, numberOfRowsInComponent component: Swift.Int) -> Swift.Int
}
extension cryptography.PersianDatePickerView : UIKit.UIPickerViewDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func pickerView(_ pickerView: UIKit.UIPickerView, viewForRow row: Swift.Int, forComponent component: Swift.Int, reusing view: UIKit.UIView?) -> UIKit.UIView
  @_Concurrency.MainActor(unsafe) @objc dynamic public func pickerView(_ pickerView: UIKit.UIPickerView, didSelectRow row: Swift.Int, inComponent component: Swift.Int)
}
public typealias Listener = (_ year: Swift.Int, _ month: Swift.Int, _ day: Swift.Int) -> Swift.Void
public enum PersianDatePickerStyle {
  case short
  case long
  public static func == (a: cryptography.PersianDatePickerStyle, b: cryptography.PersianDatePickerStyle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @objc public class NFXHTTPModel : ObjectiveC.NSObject {
  @objc public var requestURL: Swift.String?
  @objc public var requestURLComponents: Foundation.URLComponents?
  @objc public var requestURLQueryItems: [Foundation.URLQueryItem]?
  @objc public var requestMethod: Swift.String?
  @objc public var requestCachePolicy: Swift.String?
  @objc public var requestDate: Foundation.Date?
  @objc public var requestTime: Swift.String?
  @objc public var requestTimeout: Swift.String?
  @objc public var requestHeaders: [Swift.AnyHashable : Any]?
  public var requestBodyLength: Swift.Int?
  @objc public var requestType: Swift.String?
  @objc public var requestCurl: Swift.String?
  public var responseStatus: Swift.Int?
  @objc public var responseType: Swift.String?
  @objc public var responseDate: Foundation.Date?
  @objc public var responseTime: Swift.String?
  @objc public var responseHeaders: [Swift.AnyHashable : Any]?
  public var responseBodyLength: Swift.Int?
  public var timeInterval: Swift.Float?
  @objc public var randomHash: Swift.String {
    @objc get
    @objc set
  }
  public var shortType: cryptography.HTTPModelShortType
  @objc public var shortTypeString: Swift.String {
    @objc get
  }
  @objc public var noResponse: Swift.Bool
  @objc public func getRequestBody() -> Swift.String
  @objc public func getResponseBody() -> Swift.String
  @objc public func getRequestBodyFileURL() -> Foundation.URL
  @objc public func getRequestBodyFilename() -> Swift.String
  @objc public func getResponseBodyFileURL() -> Foundation.URL
  @objc public func getResponseBodyFilename() -> Swift.String
  @objc public func saveData(_ dataString: Swift.String, to fileURL: Foundation.URL)
  @objc public func readRawData(from fileURL: Foundation.URL) -> Foundation.Data?
  @objc public func getTimeFromDate(_ date: Foundation.Date) -> Swift.String?
  public func prettyPrint(_ rawData: Foundation.Data, type: cryptography.HTTPModelShortType) -> Swift.String?
  @objc public func isSuccessful() -> Swift.Bool
  @objc public func formattedRequestLogEntry() -> Swift.String
  @objc public func formattedResponseLogEntry() -> Swift.String
  @objc override dynamic public init()
  @objc deinit
}
public struct CryptoSwiftCFB : cryptography.CryptoSwiftBlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: cryptography.CryptoSwiftCFB.Error, b: cryptography.CryptoSwiftCFB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum SegmentSize : Swift.Int {
    case cfb8
    case cfb128
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public let options: cryptography.CryptoSwiftBlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>, segmentSize: cryptography.CryptoSwiftCFB.SegmentSize = .cfb128)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping cryptography.CipherOperationOnBlock, encryptionOperation: @escaping cryptography.CipherOperationOnBlock) throws -> any cryptography.CryptoSwiftCipherModeWorker
}
extension UIKit.UIWindow {
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func motionEnded(_ motion: UIKit.UIEvent.EventSubtype, with event: UIKit.UIEvent?)
}
extension UIKit.UIDevice {
  @_Concurrency.MainActor(unsafe) public class func getNFXDeviceType() -> Swift.String
  @_Concurrency.MainActor(unsafe) public class func parseDeviceType(_ identifier: Swift.String) -> Swift.String
}
public protocol RSAPublicKeyExporting {
  func toSubjectPublicKeyInfo(_ rsaPublicKey: Foundation.Data) -> Foundation.Data
}
final public class Blowfish {
  public enum Error : Swift.Error {
    case dataPaddingRequired
    case invalidKeyOrInitializationVector
    case invalidInitializationVector
    case invalidBlockMode
    public static func == (a: cryptography.Blowfish.Error, b: cryptography.Blowfish.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, blockMode: any cryptography.CryptoSwiftBlockMode = CryptoSwiftCBC(iv: Array<UInt8>(repeating: 0, count: Blowfish.blockSize)), padding: cryptography.CryptoSwiftPadding) throws
  @objc deinit
}
extension cryptography.Blowfish : cryptography.CryptoSwiftCipher {
  final public func encrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
  final public func decrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
}
extension Swift.String : Swift.Error {
}
@_hasMissingDesignatedInitializers open class RSA {
  public typealias CCAsymmetricPadding = Swift.UInt32
  public enum AsymmetricPadding : cryptography.RSA.CCAsymmetricPadding {
    case pkcs1
    case oaep
    public init?(rawValue: cryptography.RSA.CCAsymmetricPadding)
    public typealias RawValue = cryptography.RSA.CCAsymmetricPadding
    public var rawValue: cryptography.RSA.CCAsymmetricPadding {
      get
    }
  }
  public enum AsymmetricSAPadding : Swift.UInt32 {
    case pkcs15
    case pss
    public init?(rawValue: Swift.UInt32)
    public typealias RawValue = Swift.UInt32
    public var rawValue: Swift.UInt32 {
      get
    }
  }
  public static func generateKeyPair(_ keySize: Swift.Int = 4096) throws -> (Foundation.Data, Foundation.Data)
  public static func getPublicKeyFromPrivateKey(_ derKey: Foundation.Data) throws -> Foundation.Data
  public static func encrypt(_ data: Foundation.Data, derKey: Foundation.Data, tag: Foundation.Data, padding: cryptography.RSA.AsymmetricPadding, digest: cryptography.DigestAlgorithm) throws -> Foundation.Data
  public static func decrypt(_ data: Foundation.Data, derKey: Foundation.Data, tag: Foundation.Data, padding: cryptography.RSA.AsymmetricPadding, digest: cryptography.DigestAlgorithm) throws -> (Foundation.Data, Swift.Int)
  public static func importFromDERKey(_ derKey: Foundation.Data) throws -> cryptography.RSA.CCRSACryptorRef
  public static func exportToDERKey(_ key: cryptography.RSA.CCRSACryptorRef) throws -> Foundation.Data
  public static func getKeyType(_ key: cryptography.RSA.CCRSACryptorRef) -> cryptography.RSA.KeyType
  public static func getKeySize(_ key: cryptography.RSA.CCRSACryptorRef) -> Swift.Int
  public static func parsePublicSecKey(publicKey: Security.SecKey) throws -> (modulus: Foundation.Data, exponent: Foundation.Data)
  public static func convertDERtoPublicKey(publicKey: Swift.String?, secAttrKeySizeInBits: Swift.Int) -> Security.SecKey?
  public static func sign(message: Foundation.Data, derKey: Foundation.Data, padding: cryptography.RSA.AsymmetricSAPadding, digest: cryptography.DigestAlgorithm, saltLen: Swift.Int) throws -> Foundation.Data
  public static func verify(message: Foundation.Data, derKey: Foundation.Data, padding: cryptography.RSA.AsymmetricSAPadding, digest: cryptography.DigestAlgorithm, saltLen: Swift.Int, signedData: Foundation.Data) throws -> Swift.Bool
  public static func crypt(_ data: Foundation.Data, key: cryptography.RSA.CCRSACryptorRef) throws -> Foundation.Data
  public static func mgf1(_ digest: cryptography.DigestAlgorithm, seed: Foundation.Data, maskLength: Swift.Int) -> Foundation.Data
  public static func xorData(_ data1: Foundation.Data, _ data2: Foundation.Data) -> Foundation.Data
  public static func add_pss_padding(_ digest: cryptography.DigestAlgorithm, saltLength: Swift.Int, keyLength: Swift.Int, message: Foundation.Data) throws -> Foundation.Data
  public static func verify_pss_padding(_ digest: cryptography.DigestAlgorithm, saltLength: Swift.Int, keyLength: Swift.Int, message: Foundation.Data, encMessage: Foundation.Data) throws -> Swift.Bool
  public static func generateKeyPair1(_ keySize: Swift.Int = 4096) throws -> (Foundation.Data, Foundation.Data)
  public static func available() -> Swift.Bool
  public typealias CCRSACryptorRef = Swift.UnsafeRawPointer
  public typealias CCRSAKeyType = Swift.UInt32
  public enum KeyType : cryptography.RSA.CCRSAKeyType {
    case publicKey, privateKey
    case blankPublicKey, blankPrivateKey
    case badKey
    public init?(rawValue: cryptography.RSA.CCRSAKeyType)
    public typealias RawValue = cryptography.RSA.CCRSAKeyType
    public var rawValue: cryptography.RSA.CCRSAKeyType {
      get
    }
  }
  public typealias CCRSACryptorGeneratePairT = @convention(c) (_ keySize: Swift.Int, _ e: Swift.UInt32, _ publicKey: Swift.UnsafeMutablePointer<cryptography.RSA.CCRSACryptorRef?>, _ privateKey: Swift.UnsafeMutablePointer<cryptography.RSA.CCRSACryptorRef?>) -> cryptography.CC.CCCryptorStatus
  public static let CCRSACryptorGeneratePair: cryptography.RSA.CCRSACryptorGeneratePairT?
  public typealias CCRSACryptorGetPublicKeyFromPrivateKeyT = @convention(c) (cryptography.RSA.CCRSACryptorRef) -> cryptography.RSA.CCRSACryptorRef
  public static let CCRSACryptorGetPublicKeyFromPrivateKey: cryptography.RSA.CCRSACryptorGetPublicKeyFromPrivateKeyT?
  public typealias CCRSACryptorReleaseT = @convention(c) (cryptography.RSA.CCRSACryptorRef) -> Swift.Void
  public static let CCRSACryptorRelease: cryptography.RSA.CCRSACryptorReleaseT?
  public typealias CCRSAGetKeyTypeT = @convention(c) (cryptography.RSA.CCRSACryptorRef) -> cryptography.RSA.CCRSAKeyType
  public static let CCRSAGetKeyType: cryptography.RSA.CCRSAGetKeyTypeT?
  public typealias CCRSAGetKeySizeT = @convention(c) (cryptography.RSA.CCRSACryptorRef) -> Swift.Int32
  public static let CCRSAGetKeySize: cryptography.RSA.CCRSAGetKeySizeT?
  public typealias CCRSACryptorEncryptT = @convention(c) (_ publicKey: cryptography.RSA.CCRSACryptorRef, _ padding: cryptography.RSA.CCAsymmetricPadding, _ plainText: Swift.UnsafeRawPointer, _ plainTextLen: Swift.Int, _ cipherText: Swift.UnsafeMutableRawPointer, _ cipherTextLen: Swift.UnsafeMutablePointer<Swift.Int>, _ tagData: Swift.UnsafeRawPointer, _ tagDataLen: Swift.Int, _ digestType: cryptography.CC.CCDigestAlgorithm) -> cryptography.CC.CCCryptorStatus
  public static let CCRSACryptorEncrypt: cryptography.RSA.CCRSACryptorEncryptT?
  public typealias CCRSACryptorDecryptT = @convention(c) (_ privateKey: cryptography.RSA.CCRSACryptorRef, _ padding: cryptography.RSA.CCAsymmetricPadding, _ cipherText: Swift.UnsafeRawPointer, _ cipherTextLen: Swift.Int, _ plainText: Swift.UnsafeMutableRawPointer, _ plainTextLen: Swift.UnsafeMutablePointer<Swift.Int>, _ tagData: Swift.UnsafeRawPointer, _ tagDataLen: Swift.Int, _ digestType: cryptography.CC.CCDigestAlgorithm) -> cryptography.CC.CCCryptorStatus
  public static let CCRSACryptorDecrypt: cryptography.RSA.CCRSACryptorDecryptT?
  public typealias CCRSACryptorExportT = @convention(c) (_ key: cryptography.RSA.CCRSACryptorRef, _ out: Swift.UnsafeMutableRawPointer, _ outLen: Swift.UnsafeMutablePointer<Swift.Int>) -> cryptography.CC.CCCryptorStatus
  public static let CCRSACryptorExport: cryptography.RSA.CCRSACryptorExportT?
  public typealias CCRSACryptorImportT = @convention(c) (_ keyPackage: Swift.UnsafeRawPointer, _ keyPackageLen: Swift.Int, _ key: Swift.UnsafeMutablePointer<cryptography.RSA.CCRSACryptorRef?>) -> cryptography.CC.CCCryptorStatus
  public static let CCRSACryptorImport: cryptography.RSA.CCRSACryptorImportT?
  public typealias CCRSACryptorSignT = @convention(c) (_ privateKey: cryptography.RSA.CCRSACryptorRef, _ padding: cryptography.RSA.CCAsymmetricPadding, _ hashToSign: Swift.UnsafeRawPointer, _ hashSignLen: Darwin.size_t, _ digestType: cryptography.CC.CCDigestAlgorithm, _ saltLen: Darwin.size_t, _ signedData: Swift.UnsafeMutableRawPointer, _ signedDataLen: Swift.UnsafeMutablePointer<Swift.Int>) -> cryptography.CC.CCCryptorStatus
  public static let CCRSACryptorSign: cryptography.RSA.CCRSACryptorSignT?
  public typealias CCRSACryptorVerifyT = @convention(c) (_ publicKey: cryptography.RSA.CCRSACryptorRef, _ padding: cryptography.RSA.CCAsymmetricPadding, _ hash: Swift.UnsafeRawPointer, _ hashLen: Darwin.size_t, _ digestType: cryptography.CC.CCDigestAlgorithm, _ saltLen: Darwin.size_t, _ signedData: Swift.UnsafeRawPointer, _ signedDataLen: Darwin.size_t) -> cryptography.CC.CCCryptorStatus
  public static let CCRSACryptorVerify: cryptography.RSA.CCRSACryptorVerifyT?
  public typealias CCRSACryptorCryptT = @convention(c) (_ rsaKey: cryptography.RSA.CCRSACryptorRef, _ data: Swift.UnsafeRawPointer, _ dataLength: Darwin.size_t, _ out: Swift.UnsafeMutableRawPointer, _ outLength: Swift.UnsafeMutablePointer<Darwin.size_t>) -> cryptography.CC.CCCryptorStatus
  public static let CCRSACryptorCrypt: cryptography.RSA.CCRSACryptorCryptT?
  @objc deinit
}
final public class CryptoSwiftGCM : cryptography.CryptoSwiftBlockMode {
  public enum Mode {
    case combined
    case detached
    public static func == (a: cryptography.CryptoSwiftGCM.Mode, b: cryptography.CryptoSwiftGCM.Mode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let options: cryptography.CryptoSwiftBlockModeOption
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case fail
    public static func == (a: cryptography.CryptoSwiftGCM.Error, b: cryptography.CryptoSwiftGCM.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let customBlockSize: Swift.Int?
  final public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, tagLength: Swift.Int = 16, mode: cryptography.CryptoSwiftGCM.Mode = .detached)
  convenience public init(iv: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, mode: cryptography.CryptoSwiftGCM.Mode = .detached)
  final public func worker(blockSize: Swift.Int, cipherOperation: @escaping cryptography.CipherOperationOnBlock, encryptionOperation: @escaping cryptography.CipherOperationOnBlock) throws -> any cryptography.CryptoSwiftCipherModeWorker
  @objc deinit
}
final public class CryptoSwiftRabbit {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    public static func == (a: cryptography.CryptoSwiftRabbit.Error, b: cryptography.CryptoSwiftRabbit.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let ivSize: Swift.Int
  public static let keySize: Swift.Int
  public static let blockSize: Swift.Int
  final public var keySize: Swift.Int {
    get
  }
  convenience public init(key: Swift.Array<Swift.UInt8>) throws
  public init(key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>?) throws
  @objc deinit
}
extension cryptography.CryptoSwiftRabbit : cryptography.CryptoSwiftCipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
public struct RSAPublicKeyImporter : cryptography.RSAPublicKeyImporting {
  public init()
  public func fromSubjectPublicKeyInfo(_ subjectPublicKeyInfo: Foundation.Data) throws -> Foundation.Data
}
extension Swift.Array {
  @inlinable internal init(reserveCapacity: Swift.Int) {
    self = Array<Element>()
    self.reserveCapacity(reserveCapacity)
  }
  @inlinable internal var slice: Swift.ArraySlice<Element> {
    get {
    self[self.startIndex ..< self.endIndex]
  }
  }
}
extension Swift.Array where Element == Swift.UInt8 {
  public init(hex: Swift.String)
  public func toHexString() -> Swift.String
}
extension Swift.Array where Element == Swift.UInt8 {
  @available(*, deprecated)
  public func chunks(size chunksize: Swift.Int) -> Swift.Array<Swift.Array<Element>>
  public func md5() -> [Element]
  public func sha1() -> [Element]
  public func sha224() -> [Element]
  public func sha256() -> [Element]
  public func sha384() -> [Element]
  public func sha512() -> [Element]
  public func sha2(_ variant: cryptography.CryptoSwiftSHA2.Variant) -> [Element]
  public func sha3(_ variant: cryptography.CryptoSwiftSHA3.Variant) -> [Element]
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc16(seed: Swift.UInt16? = nil) -> Swift.UInt16
  public func encrypt(cipher: any cryptography.CryptoSwiftCipher) throws -> [Element]
  public func decrypt(cipher: any cryptography.CryptoSwiftCipher) throws -> [Element]
  public func authenticate<A>(with authenticator: A) throws -> [Element] where A : cryptography.CryptoSwiftAuthenticator
}
public class FoundationHTTPHandler : cryptography.HTTPHandler {
  public init()
  public func convert(request: Foundation.URLRequest) -> Foundation.Data
  public func parse(data: Foundation.Data) -> Swift.Int
  public func register(delegate: any cryptography.HTTPHandlerDelegate)
  @objc deinit
}
public protocol EngineDelegate : AnyObject {
  func didReceive(event: cryptography.WebSocketEvent)
}
public protocol Engine {
  func register(delegate: any cryptography.EngineDelegate)
  func start(request: Foundation.URLRequest)
  func stop(closeCode: Swift.UInt16)
  func forceStop()
  func write(data: Foundation.Data, opcode: cryptography.FrameOpCode, completion: (() -> ())?)
  func write(string: Swift.String, completion: (() -> ())?)
}
public enum DtbsContentTypeEnum : Swift.String, Swift.Codable {
  case textUtf
  case encodedBase64
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum DigestAlgorithm : cryptography.CC.CCDigestAlgorithm {
  case none
  case md5
  case rmd128, rmd160, rmd256, rmd320
  case sha1
  case sha224, sha256, sha384, sha512
  public init?(rawValue: cryptography.CC.CCDigestAlgorithm)
  public typealias RawValue = cryptography.CC.CCDigestAlgorithm
  public var rawValue: cryptography.CC.CCDigestAlgorithm {
    get
  }
}
extension Foundation.URLRequest {
  public enum HTTPMethod : Swift.String {
    case get
    case put
    case post
    case delete
    case head
    case options
    case trace
    case connect
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public var method: Foundation.URLRequest.HTTPMethod? {
    get
    set
  }
}
extension Foundation.URLRequest {
  public init(url: Foundation.URL, method: Foundation.URLRequest.HTTPMethod, contentType: Swift.String?)
  public init(url: Foundation.URL, method: Foundation.URLRequest.HTTPMethod, contentType: Swift.String?, body: Foundation.Data?)
  public init(url: Foundation.URL, method: Foundation.URLRequest.HTTPMethod, contentType: Swift.String?, cachePolicy: Foundation.URLRequest.CachePolicy, timeoutInterval: Foundation.TimeInterval)
}
@_hasMissingDesignatedInitializers open class CC {
  public typealias CCCryptorStatus = Swift.Int32
  public static func generateRandom(_ size: Swift.Int) -> Foundation.Data
  public typealias CCDigestAlgorithm = Swift.UInt32
  public static func digest(_ data: Foundation.Data, alg: cryptography.DigestAlgorithm) -> Foundation.Data
  public typealias CCHmacAlgorithm = Swift.UInt32
  public static func HMAC(_ data: Foundation.Data, alg: cryptography.HMACAlg, key: Foundation.Data) -> Foundation.Data
  public typealias CCOperation = Swift.UInt32
  public typealias CCMode = Swift.UInt32
  public typealias CCAlgorithm = Swift.UInt32
  public typealias CCPadding = Swift.UInt32
  public static func crypt(_ opMode: cryptography.OpMode, blockMode: cryptography.BlockMode, algorithm: cryptography.Algorithm, padding: cryptography.Padding, data: Foundation.Data, key: Foundation.Data, iv: Foundation.Data) throws -> Foundation.Data
  public static func cryptAuth(_ opMode: cryptography.OpMode, blockMode: cryptography.AuthBlockMode, algorithm: cryptography.Algorithm, data: Foundation.Data, aData: Foundation.Data, key: Foundation.Data, iv: Foundation.Data, tagLength: Swift.Int) throws -> Foundation.Data
  public static func digestAvailable() -> Swift.Bool
  public static func randomAvailable() -> Swift.Bool
  public static func hmacAvailable() -> Swift.Bool
  public static func cryptorAvailable() -> Swift.Bool
  public static func available() -> Swift.Bool
  public typealias CCCryptorRef = Swift.UnsafeRawPointer
  public typealias CCRNGStatus = cryptography.CC.CCCryptorStatus
  public typealias CC_LONG = Swift.UInt32
  public typealias CCModeOptions = Swift.UInt32
  public typealias CCRandomGenerateBytesT = @convention(c) (_ bytes: Swift.UnsafeMutableRawPointer, _ count: Darwin.size_t) -> cryptography.CC.CCRNGStatus
  public typealias CCDigestGetOutputSizeT = @convention(c) (_ algorithm: cryptography.CC.CCDigestAlgorithm) -> Darwin.size_t
  public typealias CCDigestT = @convention(c) (_ algorithm: cryptography.CC.CCDigestAlgorithm, _ data: Swift.UnsafeRawPointer, _ dataLen: Darwin.size_t, _ output: Swift.UnsafeMutableRawPointer) -> Swift.CInt
  public typealias CCHmacT = @convention(c) (_ algorithm: cryptography.CC.CCHmacAlgorithm, _ key: Swift.UnsafeRawPointer, _ keyLength: Swift.Int, _ data: Swift.UnsafeRawPointer, _ dataLength: Swift.Int, _ macOut: Swift.UnsafeMutableRawPointer) -> Swift.Void
  public typealias CCCryptorCreateWithModeT = @convention(c) (_ op: cryptography.CC.CCOperation, _ mode: cryptography.CC.CCMode, _ alg: cryptography.CC.CCAlgorithm, _ padding: cryptography.CC.CCPadding, _ iv: Swift.UnsafeRawPointer?, _ key: Swift.UnsafeRawPointer, _ keyLength: Swift.Int, _ tweak: Swift.UnsafeRawPointer?, _ tweakLength: Swift.Int, _ numRounds: Swift.Int32, _ options: cryptography.CC.CCModeOptions, _ cryptorRef: Swift.UnsafeMutablePointer<cryptography.CC.CCCryptorRef?>) -> cryptography.CC.CCCryptorStatus
  public typealias CCCryptorGetOutputLengthT = @convention(c) (_ cryptorRef: cryptography.CC.CCCryptorRef, _ inputLength: Darwin.size_t, _ final: Swift.Bool) -> Darwin.size_t
  public typealias CCCryptorUpdateT = @convention(c) (_ cryptorRef: cryptography.CC.CCCryptorRef, _ dataIn: Swift.UnsafeRawPointer, _ dataInLength: Swift.Int, _ dataOut: Swift.UnsafeMutableRawPointer, _ dataOutAvailable: Swift.Int, _ dataOutMoved: Swift.UnsafeMutablePointer<Swift.Int>) -> cryptography.CC.CCCryptorStatus
  public typealias CCCryptorFinalT = @convention(c) (_ cryptorRef: cryptography.CC.CCCryptorRef, _ dataOut: Swift.UnsafeMutableRawPointer, _ dataOutAvailable: Swift.Int, _ dataOutMoved: Swift.UnsafeMutablePointer<Swift.Int>) -> cryptography.CC.CCCryptorStatus
  public typealias CCCryptorReleaseT = @convention(c) (_ cryptorRef: cryptography.CC.CCCryptorRef) -> cryptography.CC.CCCryptorStatus
  public static let dl: Swift.UnsafeMutableRawPointer?
  public static let CCDigestGetOutputSize: cryptography.CC.CCDigestGetOutputSizeT?
  public static let CCDigest: cryptography.CC.CCDigestT?
  public static let CCHmac: cryptography.CC.CCHmacT?
  public static let CCCryptorCreateWithMode: cryptography.CC.CCCryptorCreateWithModeT?
  public static let CCCryptorGetOutputLength: cryptography.CC.CCCryptorGetOutputLengthT?
  public static let CCCryptorUpdate: cryptography.CC.CCCryptorUpdateT?
  public static let CCCryptorFinal: cryptography.CC.CCCryptorFinalT?
  public static let CCCryptorRelease: cryptography.CC.CCCryptorReleaseT?
  @objc deinit
}
public protocol CompressionHandler {
  func load(headers: [Swift.String : Swift.String])
  func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  func compress(data: Foundation.Data) -> Foundation.Data?
}
final public class ChaCha20 {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    case notSupported
    public static func == (a: cryptography.ChaCha20.Error, b: cryptography.ChaCha20.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, iv nonce: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
extension cryptography.ChaCha20 : cryptography.CryptoSwiftCipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension cryptography.ChaCha20 {
  public struct ChaChaEncryptor : cryptography.CryptoSwiftCryptor, cryptography.CryptoSwiftUpdatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension cryptography.ChaCha20 {
  public struct ChaChaDecryptor : cryptography.CryptoSwiftCryptor, cryptography.CryptoSwiftUpdatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = true) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension cryptography.ChaCha20 : cryptography.CryptoSwiftCryptors {
  final public func makeEncryptor() -> any cryptography.CryptoSwiftCryptor & cryptography.CryptoSwiftUpdatable
  final public func makeDecryptor() -> any cryptography.CryptoSwiftCryptor & cryptography.CryptoSwiftUpdatable
}
@_hasMissingDesignatedInitializers open class KeyWrap {
  public static let rfc3394IV: Foundation.Data
  public static func SymmetricKeyWrap(_ iv: Foundation.Data, kek: Foundation.Data, rawKey: Foundation.Data) throws -> Foundation.Data
  public static func SymmetricKeyUnwrap(_ iv: Foundation.Data, kek: Foundation.Data, wrappedKey: Foundation.Data) throws -> Foundation.Data
  public static func available() -> Swift.Bool
  @objc deinit
}
public class PKCS7 {
  final public let mainBlock: cryptography.ASN1Object
  public init(data: Foundation.Data) throws
  public var digestAlgorithm: Swift.String? {
    get
  }
  public var digestAlgorithmName: Swift.String? {
    get
  }
  public var certificate: cryptography.X509Certificate? {
    get
  }
  public var certificates: [cryptography.X509Certificate] {
    get
  }
  public var data: Foundation.Data? {
    get
  }
  @objc deinit
}
extension Swift.FixedWidthInteger {
  @inlinable internal func bytes(totalBytes: Swift.Int = MemoryLayout<Self>.size) -> Swift.Array<Swift.UInt8> {
    arrayOfBytes(value: self.littleEndian, length: totalBytes)
    // TODO: adjust bytes order
    // var value = self.littleEndian
    // return withUnsafeBytes(of: &value, Array.init).reversed()
  }
}
@_hasMissingDesignatedInitializers public class ASN1Identifier : Swift.CustomStringConvertible {
  public enum Class : Swift.UInt8 {
    case universal
    case application
    case contextSpecific
    case `private`
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public enum TagNumber : Swift.UInt8 {
    case endOfContent
    case boolean
    case integer
    case bitString
    case octetString
    case null
    case objectIdentifier
    case objectDescriptor
    case external
    case read
    case enumerated
    case embeddedPdv
    case utf8String
    case relativeOid
    case sequence
    case set
    case numericString
    case printableString
    case t61String
    case videotexString
    case ia5String
    case utcTime
    case generalizedTime
    case graphicString
    case visibleString
    case generalString
    case universalString
    case characterString
    case bmpString
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public static let constructedTag: Swift.UInt8
  public func typeClass() -> cryptography.ASN1Identifier.Class
  public func isPrimitive() -> Swift.Bool
  public func isConstructed() -> Swift.Bool
  public func tagNumber() -> cryptography.ASN1Identifier.TagNumber
  public var description: Swift.String {
    get
  }
  @objc deinit
}
public func withUnsafePointers<A0, A1, Result>(_ arg0: Foundation.Data, _ arg1: Foundation.Data, _ body: (Swift.UnsafePointer<A0>, Swift.UnsafePointer<A1>) throws -> Result) rethrows -> Result
public func withUnsafePointers<A0, A1, Result>(_ arg0: Foundation.Data, _ arg1: inout Foundation.Data, _ body: (Swift.UnsafePointer<A0>, Swift.UnsafeMutablePointer<A1>) throws -> Result) rethrows -> Result
public func withUnsafePointers<A0, A1, A2, Result>(_ arg0: Foundation.Data, _ arg1: Foundation.Data, _ arg2: inout Foundation.Data, _ body: (Swift.UnsafePointer<A0>, Swift.UnsafePointer<A1>, Swift.UnsafeMutablePointer<A2>) throws -> Result) rethrows -> Result
public func withUnsafePointers<A0, A1, A2, Result>(_ arg0: inout Foundation.Data, _ arg1: inout Foundation.Data, _ arg2: inout Foundation.Data, _ body: (Swift.UnsafeMutablePointer<A0>, Swift.UnsafeMutablePointer<A1>, Swift.UnsafeMutablePointer<A2>) throws -> Result) rethrows -> Result
public func withUnsafePointers<A0, A1, A2, A3, Result>(_ arg0: Foundation.Data, _ arg1: Foundation.Data, _ arg2: Foundation.Data, _ arg3: inout Foundation.Data, _ body: (Swift.UnsafePointer<A0>, Swift.UnsafePointer<A1>, Swift.UnsafePointer<A2>, Swift.UnsafeMutablePointer<A3>) throws -> Result) rethrows -> Result
public func withUnsafePointers<A0, A1, A2, A3, A4, A5, Result>(_ arg0: Foundation.Data, _ arg1: Foundation.Data, _ arg2: Foundation.Data, _ arg3: Foundation.Data, _ arg4: inout Foundation.Data, _ arg5: inout Foundation.Data, _ body: (Swift.UnsafePointer<A0>, Swift.UnsafePointer<A1>, Swift.UnsafePointer<A2>, Swift.UnsafePointer<A3>, Swift.UnsafeMutablePointer<A4>, Swift.UnsafeMutablePointer<A5>) throws -> Result) rethrows -> Result
public func getFunc<T>(_ from: Swift.UnsafeMutableRawPointer, f: Swift.String) -> T?
extension Foundation.Data {
  public func hexadecimalString() -> Swift.String
  public func arrayOfBytes() -> [Swift.UInt8]
  public var bytesView: Foundation.Data.BytesView {
    get
  }
  public func bytesViewRange(_ range: Foundation.NSRange) -> Foundation.Data.BytesView
  public struct BytesView : Swift.Collection {
    public subscript(position: Swift.Int) -> Swift.UInt8 {
      get
    }
    public subscript(bounds: Swift.Range<Swift.Int>) -> Foundation.Data {
      get
    }
    public func formIndex(after i: inout Swift.Int)
    public func index(after i: Swift.Int) -> Swift.Int
    public var startIndex: Swift.Int
    public var endIndex: Swift.Int
    public var length: Swift.Int {
      get
    }
    public typealias Element = Swift.UInt8
    public typealias Index = Swift.Int
    public typealias Indices = Swift.DefaultIndices<Foundation.Data.BytesView>
    public typealias Iterator = Swift.IndexingIterator<Foundation.Data.BytesView>
    public typealias SubSequence = Foundation.Data
  }
}
extension Swift.String {
  public func dataFromHexadecimalString() -> Foundation.Data?
}
@_inheritsConvenienceInitializers @objc(KeyInfomationEntity) public class KeyInfomationEntity : CoreData.NSManagedObject {
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  @objc deinit
}
public protocol CryptoSwiftCipherModeWorker {
  var cipherOperation: cryptography.CipherOperationOnBlock { get }
  var additionalBufferSize: Swift.Int { get }
  @inlinable mutating func encrypt(block plaintext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @inlinable mutating func decrypt(block ciphertext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
}
public protocol CryptoSwiftBlockModeWorker : cryptography.CryptoSwiftCipherModeWorker {
  var blockSize: Swift.Int { get }
}
public protocol CryptoSwiftCounterModeWorker : cryptography.CryptoSwiftCipherModeWorker {
  associatedtype Counter
  var counter: Self.Counter { get set }
}
public protocol CryptoSwiftSeekableModeWorker : cryptography.CryptoSwiftCipherModeWorker {
  mutating func seek(to position: Swift.Int) throws
}
public protocol CryptoSwiftStreamModeWorker : cryptography.CryptoSwiftCipherModeWorker {
}
public protocol CryptoSwiftFinalizingEncryptModeWorker : cryptography.CryptoSwiftCipherModeWorker {
  mutating func finalize(encrypt ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
public protocol CryptoSwiftFinalizingDecryptModeWorker : cryptography.CryptoSwiftCipherModeWorker {
  @discardableResult
  mutating func willDecryptLast(bytes ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func didDecryptLast(bytes plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func finalize(decrypt plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
public enum MsauLanguagesEnum : Swift.String {
  case en
  case fa
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ASN1ReadError : Swift.Equatable {
  case invalidIdentifier(expectedIdentifier: Swift.UInt8, actualIdentifier: Swift.UInt8, atPosition: Swift.Int, ofEncoding: [Swift.UInt8])
  case invalidBytes(expectedBytes: [Swift.UInt8], actualBytes: [Swift.UInt8], atPosition: Swift.Int, ofEncoding: [Swift.UInt8])
  case invalidLength(minimumRemainingBytes: Swift.Int, forReading: Swift.String, actualRemainingBytes: Swift.Int, atPosition: Swift.Int, ofEncoding: [Swift.UInt8])
  case unsupportedFirstContentsByte(actualByte: Swift.UInt8, atPosition: Swift.Int, ofEncoding: [Swift.UInt8])
  case indefiniteLengthNotSupported(atPosition: Swift.Int)
  public static func == (a: cryptography.ASN1ReadError, b: cryptography.ASN1ReadError) -> Swift.Bool
}
extension cryptography.ASN1ReadError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
@_hasMissingDesignatedInitializers public class ASN1DEREncoder {
  public static func encodeSequence(content: Foundation.Data) -> Foundation.Data
  @objc deinit
}
extension Foundation.Data {
  public var derEncodedSequence: Foundation.Data {
    get
  }
}
public enum PEMError : Swift.Error {
  case parse(Swift.String)
  case badPassphrase
  case keyNotEncrypted
  public static var debugLevel: Swift.Int
}
public enum LoginType {
  case loginToHome, loginToIssueCert
  public static func == (a: cryptography.LoginType, b: cryptography.LoginType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class CryptoSwiftMD5 {
  public init()
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension cryptography.CryptoSwiftMD5 : cryptography.CryptoSwiftUpdatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
public enum DisplayMessageContentTypeEnum : Swift.String, Swift.Codable {
  case textUtf
  case urlLink
  case filePdf
  public var value: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class OtpTextField : UIKit.UITextField {
  @_Concurrency.MainActor(unsafe) public var otpDefaultCharacter: Swift.String
  @_Concurrency.MainActor(unsafe) public var otpBackgroundColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var otpFilledBackgroundColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var otpCornerRaduis: CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) public var otpDefaultBorderColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var otpFilledBorderColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var otpDefaultBorderWidth: CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) public var otpFilledBorderWidth: CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) public var otpTextColor: UIKit.UIColor
  @_Concurrency.MainActor(unsafe) public var otpFontSize: CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) public var otpFont: UIKit.UIFont {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) weak public var otpDelegate: (any cryptography.OtpTextFieldDelegate)?
  @_Concurrency.MainActor(unsafe) public func configure(with slotCount: Swift.Int = 6)
  @_Concurrency.MainActor(unsafe) public func clearOTP()
  @_Concurrency.MainActor(unsafe) public func setText(_ text: Swift.String)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension cryptography.OtpTextField : UIKit.UITextFieldDelegate {
}
final public class CryptoSwiftHMAC : cryptography.CryptoSwiftAuthenticator {
  public enum Error : Swift.Error {
    case authenticateError
    case invalidInput
    public static func == (a: cryptography.CryptoSwiftHMAC.Error, b: cryptography.CryptoSwiftHMAC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Variant {
    case md5
    case sha1
    case sha2(cryptography.CryptoSwiftSHA2.Variant)
    case sha3(cryptography.CryptoSwiftSHA3.Variant)
    @available(*, deprecated, message: "Use sha2(variant) instead.")
    case sha256, sha384, sha512
  }
  public init(key: Swift.Array<Swift.UInt8>, variant: cryptography.CryptoSwiftHMAC.Variant = .md5)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public class NativeEngine : ObjectiveC.NSObject, cryptography.Engine, Foundation.URLSessionDataDelegate, Foundation.URLSessionWebSocketDelegate {
  public func register(delegate: any cryptography.EngineDelegate)
  public func start(request: Foundation.URLRequest)
  public func stop(closeCode: Swift.UInt16)
  public func forceStop()
  public func write(string: Swift.String, completion: (() -> ())?)
  public func write(data: Foundation.Data, opcode: cryptography.FrameOpCode, completion: (() -> ())?)
  @objc public func urlSession(_ session: Foundation.URLSession, webSocketTask: Foundation.URLSessionWebSocketTask, didOpenWithProtocol protocol: Swift.String?)
  @objc public func urlSession(_ session: Foundation.URLSession, webSocketTask: Foundation.URLSessionWebSocketTask, didCloseWith closeCode: Foundation.URLSessionWebSocketTask.CloseCode, reason: Foundation.Data?)
  @objc override dynamic public init()
  @objc deinit
}
public enum CryptoSwiftPKCS5 {
}
@objc public class CircularProgressBar : QuartzCore.CALayer {
  public var progressLabel: UIKit.UILabel!
  public var isUsingAnimation: Swift.Bool!
  public var progress: CoreFoundation.CGFloat {
    get
    set
  }
  public init(radius: CoreFoundation.CGFloat, position: CoreFoundation.CGPoint, innerTrackColor: UIKit.UIColor, outerTrackColor: UIKit.UIColor, lineWidth: CoreFoundation.CGFloat, progressLabelVisibility: Swift.Bool, progressLabelColor: UIKit.UIColor?, progressLabelSize: CoreFoundation.CGFloat?)
  @objc override dynamic public init(layer: Any)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  public func invalidateProgress()
  @objc deinit
}
extension cryptography.CryptoSwiftAES {
  convenience public init(key: Swift.String, iv: Swift.String, padding: cryptography.CryptoSwiftPadding = .pkcs7) throws
}
public enum VideoQuality {
  case very_high
  case high
  case medium
  case low
  case very_low
  public static func == (a: cryptography.VideoQuality, b: cryptography.VideoQuality) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum CompressionResult {
  case onStart
  case onSuccess(Swift.Int, Foundation.URL)
  case onFailure(Swift.Int, cryptography.CompressionError)
  case onCancelled
}
public class Compression {
  public init()
  public var cancel: Swift.Bool
  @objc deinit
}
public struct CompressionError : Foundation.LocalizedError {
  public let title: Swift.String
}
public struct LightCompressor {
  public struct Video {
    public struct Configuration {
      public let quality: cryptography.VideoQuality
      public let isMinBitrateCheckEnabled: Swift.Bool
      public let videoBitrateInMbps: Swift.Int?
      public let disableAudio: Swift.Bool
      public let keepOriginalResolution: Swift.Bool
      public let videoSize: CoreFoundation.CGSize?
      public init(quality: cryptography.VideoQuality = .medium, isMinBitrateCheckEnabled: Swift.Bool = true, videoBitrateInMbps: Swift.Int? = nil, disableAudio: Swift.Bool = false, keepOriginalResolution: Swift.Bool = false, videoSize: CoreFoundation.CGSize? = nil)
    }
    public let source: Foundation.URL
    public let destination: Foundation.URL
    public let configuration: cryptography.LightCompressor.Video.Configuration
    public init(source: Foundation.URL, destination: Foundation.URL, configuration: cryptography.LightCompressor.Video.Configuration = Configuration())
  }
  public init()
  public func compressVideo(videos: [cryptography.LightCompressor.Video], progressQueue: Dispatch.DispatchQueue = .main, progressHandler: ((Foundation.Progress) -> ())?, completion: @escaping (cryptography.CompressionResult) -> ()) -> cryptography.Compression
}
extension UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public func showAnimation(_ completionBlock: @escaping () -> Swift.Void)
}
public struct CertificateKeyInformation {
  public var keyId: Swift.Int
  public var certificateEncodedBase64: Swift.String?
  public var issuerCertEncodedBase64: Swift.String?
  public var keyAlgorithm: Swift.String
  public var keyLengthBits: Swift.Int
  public var keyProtectionType: Swift.String
  public var publicKeyPEM: Swift.String?
  public var serialNumber: Swift.String?
  public var issuerName: Swift.String?
  public var ownerName: Swift.String?
  public var ownerFamily: Swift.String?
  public var startDate: Foundation.Date?
  public var expirationDate: Foundation.Date?
  public init(keyId: Swift.Int, certificateEncodedBase64: Swift.String? = nil, issuerCertEncodedBase64: Swift.String? = nil, keyAlgorithm: Swift.String, keyLengthBits: Swift.Int, keyProtectionType: Swift.String, publicKeyPEM: Swift.String? = nil, serialNumber: Swift.String? = nil, issuerName: Swift.String? = nil, ownerName: Swift.String? = nil, ownerFamily: Swift.String? = nil, startDate: Foundation.Date? = nil, expirationDate: Foundation.Date? = nil)
}
public struct CertificateUserKeyInformation {
  public let uuid: Swift.String
  public let phoneNum: Swift.String?
  public var certificateKeyInformations: [cryptography.CertificateKeyInformation]?
  public let nationalId: Swift.String?
  public let firstNameLatin: Swift.String?
  public let lastNameLatin: Swift.String?
  public let birthDate: Swift.String?
  public var physicalSignature: UIKit.UIImage?
  public let email: Swift.String?
  public init(uuid: Swift.String, phoneNum: Swift.String?, certificateKeyInformations: [cryptography.CertificateKeyInformation]?, nationalId: Swift.String?, firstNameLatin: Swift.String?, lastNameLatin: Swift.String?, birthDate: Swift.String?, physicalSignature: UIKit.UIImage?, email: Swift.String?)
}
public enum CloseCode : Swift.UInt16 {
  case normal
  case goingAway
  case protocolError
  case protocolUnhandledType
  case noStatusReceived
  case encoding
  case policyViolated
  case messageTooBig
  public init?(rawValue: Swift.UInt16)
  public typealias RawValue = Swift.UInt16
  public var rawValue: Swift.UInt16 {
    get
  }
}
public enum FrameOpCode : Swift.UInt8 {
  case continueFrame
  case textFrame
  case binaryFrame
  case connectionClose
  case ping
  case pong
  case unknown
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public struct Frame {
}
public enum FrameEvent {
  case frame(cryptography.Frame)
  case error(any Swift.Error)
}
public protocol FramerEventClient : AnyObject {
  func frameProcessed(event: cryptography.FrameEvent)
}
public protocol Framer {
  func add(data: Foundation.Data)
  func register(delegate: any cryptography.FramerEventClient)
  func createWriteFrame(opcode: cryptography.FrameOpCode, payload: Foundation.Data, isCompressed: Swift.Bool) -> Foundation.Data
  func updateCompression(supports: Swift.Bool)
  func supportsCompression() -> Swift.Bool
}
public class WSFramer : cryptography.Framer {
  public var compressionEnabled: Swift.Bool
  public init(isServer: Swift.Bool = false)
  public func updateCompression(supports: Swift.Bool)
  public func supportsCompression() -> Swift.Bool
  public func add(data: Foundation.Data)
  public func register(delegate: any cryptography.FramerEventClient)
  public func createWriteFrame(opcode: cryptography.FrameOpCode, payload: Foundation.Data, isCompressed: Swift.Bool) -> Foundation.Data
  @objc deinit
}
public protocol MyWSArrayType {
}
extension Swift.UInt8 : cryptography.MyWSArrayType {
}
extension Swift.Array where Element : Swift.UnsignedInteger, Element : cryptography.MyWSArrayType {
  public func readUint16(offset: Swift.Int) -> Swift.UInt16
  public func readUint64(offset: Swift.Int) -> Swift.UInt64
  public func unmaskData(maskStart: Swift.Int, offset: Swift.Int, length: Swift.Int) -> Foundation.Data
}
public func writeUint16(_ buffer: inout [Swift.UInt8], offset: Swift.Int, value: Swift.UInt16)
public func writeUint32(_ buffer: inout [Swift.UInt8], offset: Swift.Int, value: Swift.UInt32)
public func writeUint64(_ buffer: inout [Swift.UInt8], offset: Swift.Int, value: Swift.UInt64)
public protocol OtpTextFieldDelegate : AnyObject {
  func didUserFinishEnter(the code: Swift.String)
}
public enum ErrorCodeHovita {
  public enum ClinetGereated : Swift.Int {
    case OK
    case BAD_KEY_TYPET
    case KEY_ALG_NOT_SUPPORTT
    case BAD_MSISDNT
    case BAD_DCST
    case BAD_MESSAGET
    case BAD_SIGN_MECHANISMT
    case INTERNAL_ERRORT
    case USER_DECLINET
    case USER_UNAUTHORIZEDT
    case MISSING_PARAMT
    case NO_ENTITYT
    case DUPLICATE_ENTITYT
    case BAD_CERTT
    case BAD_PARAMT
    case SIGNATURE_PROBLEMT
    case CRYPT_PROBLEMT
    case USER_RECEIVED_REQUEST_BUT_POSTPONED_RESPONSE
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public enum Auth : Swift.Int {
    case NONE_USER
    case BAD_INPUT
    case UNAUTHORIZED
    case BAD_OTP
    case WRONG_PASS
    case LOCKED
    case BAD_CREDENTIALS
    case NO_CONNECTION
    case WRONG_MSISDN_SIGN
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public enum DISPATCHER : Swift.Int {
    case JWT_EXPIRED
    case JWT_INVALID_SIGNATURE
    case JWT_BAD_FORMAT
    case JWT_INVALID_SCOPE
    case JWT_INVALID_UUID
    case JWT_INVALID_EXPIRATION_DATE
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public enum RA : Swift.Int {
    case ISSUE_IN_PROGRESS
    case INTERNAL_ERROR
    case UNKNOWN_ERROR
    case WRONG_PARAM
    case MISSING_PARAM
    case USER_PROFILE_NOT_FOUND
    case USER_WAS_DEAD
    case USER_PROFILE_PROVIDER_CONNECTION_ERROR
    case PHONE_POSSESSION_PROFILE_NOT_FOUND
    case PHONE_POSSESSION_INVALID
    case PHONE_POSSESSION_PROFILE_PROVIDER_CONNECTION_ERROR
    case CERT_NOT_FOUND
    case CA_AUTHENTICATION_FAILED
    case CA_CONNECTION_PROBLEM
    case FETCH_CERT_PROBLEM
    case CERT_REVOKED_FORMERLY
    case CERT_REVOKED_PROBLEM
    case TX_NOT_FOUND
    case MSSP_CONNECTION_ERROR
    case PAYMENT_REQUIRED
    case PAYMENT_PROVIDER_CONNECTION_ERROR
    case PAYMENT_PROVIDER_REQUEST_FAILED
    case PAYMENT_DUPLICATE_ERROR
    case PAYMENT_INVALID_PAYMENT_TRACING_CODE
    case PAYMENT_INVALID_PAYMENT_TICKET_CODE
    case INVALID_EKYC_TRACKING_CODE
    case EKYC_PROVIDER_CONNECTION_ERROR
    case RA_EKYC_UNKNOWN_ERROR
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
final public class CryptoSwiftSHA3 {
  final public let blockSize: Swift.Int
  final public let digestLength: Swift.Int
  final public let markByte: Swift.UInt8
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var accumulatedHash: Swift.Array<Swift.UInt64>
  public enum Variant {
    case sha224, sha256, sha384, sha512, keccak224, keccak256, keccak384, keccak512
    public var outputLength: Swift.Int {
      get
    }
    public static func == (a: cryptography.CryptoSwiftSHA3.Variant, b: cryptography.CryptoSwiftSHA3.Variant) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(variant: cryptography.CryptoSwiftSHA3.Variant)
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  @usableFromInline
  final internal func process(block chunk: Swift.ArraySlice<Swift.UInt64>, currentHash hh: inout Swift.Array<Swift.UInt64>)
  @objc deinit
}
extension cryptography.CryptoSwiftSHA3 : cryptography.CryptoSwiftUpdatable {
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      // Add padding
      let markByteIndex = self.accumulated.count

      // We need to always pad the input. Even if the input is a multiple of blockSize.
      let r = self.blockSize * 8
      let q = (r / 8) - (accumulated.count % (r / 8))
      self.accumulated += Array<UInt8>(repeating: 0, count: q)

      self.accumulated[markByteIndex] |= self.markByte
      self.accumulated[self.accumulated.count - 1] |= 0x80
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: self.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= self.blockSize {
        self.process(block: chunk.toUInt64Array().slice, currentHash: &self.accumulatedHash)
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)

    // TODO: verify performance, reduce vs for..in
    let result = self.accumulatedHash.reduce(into: Array<UInt8>()) { (result, value) in
      result += value.bigEndian.bytes()
    }

    // reset hash value for instance
    if isLast {
      self.accumulatedHash = Array<UInt64>(repeating: 0, count: self.digestLength)
    }

    return Array(result[0..<self.digestLength])
  }
}
extension Swift.Array where Element == Swift.UInt8 {
  public func toBase64() -> Swift.String
  public init(base64: Swift.String)
}
public enum ConnectionState {
  case connected
  case waiting
  case cancelled
  case failed((any Swift.Error)?)
  case viability(Swift.Bool)
  case shouldReconnect(Swift.Bool)
  case receive(Foundation.Data)
}
public protocol TransportEventClient : AnyObject {
  func connectionChanged(state: cryptography.ConnectionState)
}
public protocol Transport : AnyObject {
  func register(delegate: any cryptography.TransportEventClient)
  func connect(url: Foundation.URL, timeout: Swift.Double, certificatePinning: (any cryptography.CertificatePinning)?)
  func disconnect()
  func write(data: Foundation.Data, completion: @escaping (((any Swift.Error)?) -> ()))
  var usingTLS: Swift.Bool { get }
}
public enum TouchState {
  case began
  case moved
  case ended
  case none
  public static func == (a: cryptography.TouchState, b: cryptography.TouchState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class DrawSignatureView : UIKit.UIView {
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var lineWidth: CoreFoundation.CGFloat
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var strokeColor: UIKit.UIColor
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) public var signatureIsOpaque: Swift.Bool
  @_Concurrency.MainActor(unsafe) public var currentTouchState: ((cryptography.TouchState) -> ())?
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func awakeFromNib()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) public var hasSignature: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func touchesBegan(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func touchesMoved(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func touchesEnded(_ touches: Swift.Set<UIKit.UITouch>, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func draw(_ rect: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) public func captureSignature(_ signature: (cryptography.Signature?) -> ())
  @_Concurrency.MainActor(unsafe) public func captureSignatureFromViewP() -> UIKit.UIImage?
  @_Concurrency.MainActor(unsafe) public func convertViewToSignatureUIImage() -> UIKit.UIImage?
  @_Concurrency.MainActor(unsafe) public func captureSignatureFromView() -> UIKit.UIImage?
  @_Concurrency.MainActor(unsafe) public func erase()
  @objc deinit
}
public struct Signature {
  public var image: UIKit.UIImage {
    get
  }
  public var date: Foundation.Date {
    get
  }
}
extension cryptography.TransactionEntity {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<cryptography.TransactionEntity>
  @objc @NSManaged dynamic public var clientAcknowledgmentContent: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var creationDate: Foundation.Date? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var lastUpdateDate: Foundation.Date? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var messageId: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var messageType: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var metaData: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var pdfFileContent: Foundation.Data? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var serverSolicitationContent: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var transactionResultStatus: Swift.String? {
    @objc get
    @objc set
  }
}
public struct CryptoSwiftCBC : cryptography.CryptoSwiftBlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: cryptography.CryptoSwiftCBC.Error, b: cryptography.CryptoSwiftCBC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: cryptography.CryptoSwiftBlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping cryptography.CipherOperationOnBlock, encryptionOperation: @escaping cryptography.CipherOperationOnBlock) throws -> any cryptography.CryptoSwiftCipherModeWorker
}
public struct CryptoSwiftOFB : cryptography.CryptoSwiftBlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: cryptography.CryptoSwiftOFB.Error, b: cryptography.CryptoSwiftOFB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: cryptography.CryptoSwiftBlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping cryptography.CipherOperationOnBlock, encryptionOperation: @escaping cryptography.CipherOperationOnBlock) throws -> any cryptography.CryptoSwiftCipherModeWorker
}
@_inheritsConvenienceInitializers @objc(ArchivedTransactionEntity) public class ArchivedTransactionEntity : CoreData.NSManagedObject {
  @objc override dynamic public init(entity: CoreData.NSEntityDescription, insertInto context: CoreData.NSManagedObjectContext?)
  @objc deinit
}
@objc public protocol MTSlideToOpenDelegate {
  @objc func mtSlideToOpenDelegateDidFinish(_ sender: cryptography.SlideToOpenButton)
}
@objc @_inheritsConvenienceInitializers @objcMembers @_Concurrency.MainActor(unsafe) public class SlideToOpenButton : UIKit.UIView {
  @objc @_Concurrency.MainActor(unsafe) final public let textLabel: UIKit.UILabel
  @objc @_Concurrency.MainActor(unsafe) final public let sliderTextLabel: UIKit.UILabel
  @objc @_Concurrency.MainActor(unsafe) final public let thumnailImageView: UIKit.UIImageView
  @objc @_Concurrency.MainActor(unsafe) final public let sliderHolderView: UIKit.UIView
  @objc @_Concurrency.MainActor(unsafe) final public let draggedView: UIKit.UIView
  @objc @_Concurrency.MainActor(unsafe) final public let view: UIKit.UIView
  @objc @_Concurrency.MainActor(unsafe) weak public var delegate: (any cryptography.MTSlideToOpenDelegate)?
  @objc @_Concurrency.MainActor(unsafe) public var animationVelocity: Swift.Double
  @objc @_Concurrency.MainActor(unsafe) public var sliderViewTopDistance: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) public var thumbnailViewTopDistance: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) public var thumbnailViewStartingDistance: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) public var textLabelLeadingDistance: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) public var isEnabled: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) public var showSliderText: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) public var animationChangedEnabledBlock: ((Swift.Bool) -> Swift.Void)?
  @objc @_Concurrency.MainActor(unsafe) public var sliderCornerRadius: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) public var sliderBackgroundColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) public var textColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) public var slidingColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) public var thumbnailColor: UIKit.UIColor {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) public var labelText: Swift.String {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) public var textFont: UIKit.UIFont {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc @_Concurrency.MainActor(unsafe) public func resetStateWithAnimation(_ animated: Swift.Bool)
  @objc deinit
}
@_hasMissingDesignatedInitializers open class PEM {
  public static func stripHeaderFooter(_ data: Swift.String, header: Swift.String, footer: Swift.String) -> Swift.String?
  public static func base64Decode(_ base64Data: Swift.String) -> Foundation.Data?
  public static func base64Encode(_ key: Foundation.Data) -> Swift.String
  @objc deinit
}
public enum Model : Swift.String {
  case simulator, iPod1, iPod2, iPod3, iPod4, iPod5, iPod6, iPod7, iPad2, iPad3, iPad4, iPadAir, iPadAir2, iPadAir3, iPadAir4, iPad5, iPad6, iPad7, iPad8, iPad9, iPadMini, iPadMini2, iPadMini3, iPadMini4, iPadMini5, iPadMini6, iPadPro9_7, iPadPro10_5, iPadPro11, iPadPro2_11, iPadPro3_11, iPadPro12_9, iPadPro2_12_9, iPadPro3_12_9, iPadPro4_12_9, iPadPro5_12_9, iPhone4, iPhone4S, iPhone5, iPhone5S, iPhone5C, iPhone6, iPhone6Plus, iPhone6S, iPhone6SPlus, iPhoneSE, iPhone7, iPhone7Plus, iPhone8, iPhone8Plus, iPhoneX, iPhoneXS, iPhoneXSMax, iPhoneXR, iPhone11, iPhone11Pro, iPhone11ProMax, iPhoneSE2, iPhone12Mini, iPhone12, iPhone12Pro, iPhone12ProMax, iPhone13Mini, iPhone13, iPhone13Pro, iPhone13ProMax, AppleWatch1, AppleWatchS1, AppleWatchS2, AppleWatchS3, AppleWatchS4, AppleWatchS5, AppleWatchSE, AppleWatchS6, AppleWatchS7, AppleTV1, AppleTV2, AppleTV3, AppleTV4, AppleTV_4K, AppleTV2_4K, unrecognized
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension UIKit.UIDevice {
  @_Concurrency.MainActor(unsafe) public var type: cryptography.Model {
    get
  }
}
extension UIKit.UIDevice {
  @_Concurrency.MainActor(unsafe) public static var isSimulator: Swift.Bool
}
extension UIKit.UIDevice {
  @_Concurrency.MainActor(unsafe) public var typeModel: cryptography.Model {
    get
  }
}
public enum SocketCertificatePinningError : Swift.Error, Swift.Equatable {
  case invalidRequest
  public var description: Swift.String {
    get
  }
  public var customDescription: Swift.String {
    get
  }
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: cryptography.SocketCertificatePinningError, b: cryptography.SocketCertificatePinningError) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
public class SocketCertificatePinning : cryptography.CertificatePinning {
  public init(certificatesOfConfig: [Foundation.Data], domainHost: Swift.String)
  public func evaluateTrust(trust: Security.SecTrust, domain: Swift.String?, completion: ((cryptography.PinningState) -> ()))
  @objc deinit
}
public protocol CryptoSwiftPaddingProtocol {
  func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
}
public enum CryptoSwiftPadding : cryptography.CryptoSwiftPaddingProtocol {
  case noPadding, zeroPadding, pkcs7, pkcs5, iso78164, iso10126
  public func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  public func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
  public static func == (a: cryptography.CryptoSwiftPadding, b: cryptography.CryptoSwiftPadding) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension cryptography.KeyInfomationEntity {
  @nonobjc public class func fetchRequest() -> CoreData.NSFetchRequest<cryptography.KeyInfomationEntity>
  @objc @NSManaged dynamic public var certificate64: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var exponent: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var issuerCertBase64: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var keyAlgorithm: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var keyId: Swift.Int64 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var keyLengthBits: Swift.Int64 {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var keyProtectionType: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var keyTag: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var metaData: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var modulus: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var privateKeyPEM: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var publicKeyPEM: Swift.String? {
    @objc get
    @objc set
  }
  @objc @NSManaged dynamic public var status: Swift.String? {
    @objc get
    @objc set
  }
}
@_hasMissingDesignatedInitializers open class KeyDerivation {
  public typealias CCPseudoRandomAlgorithm = Swift.UInt32
  public enum PRFAlg : cryptography.KeyDerivation.CCPseudoRandomAlgorithm {
    case sha1, sha224, sha256, sha384, sha512
    public init?(rawValue: cryptography.KeyDerivation.CCPseudoRandomAlgorithm)
    public typealias RawValue = cryptography.KeyDerivation.CCPseudoRandomAlgorithm
    public var rawValue: cryptography.KeyDerivation.CCPseudoRandomAlgorithm {
      get
    }
  }
  public static func PBKDF2(_ password: Swift.String, salt: Foundation.Data, prf: cryptography.KeyDerivation.PRFAlg, rounds: Swift.UInt32) throws -> Foundation.Data
  public static func available() -> Swift.Bool
  @objc deinit
}
@_hasMissingDesignatedInitializers open class KeyConvertPrivateKey {
  public static func pemToPKCS1DER(_ pemKey: Swift.String) throws -> Foundation.Data
  public static func derToPKCS1PEM(_ derKey: Foundation.Data) -> Swift.String
  public typealias EncMode = cryptography.PEMEncryptedPrivateKey.EncMode
  public static func encryptPEM(_ pemKey: Swift.String, passphrase: Swift.String, mode: cryptography.KeyConvertPrivateKey.EncMode) throws -> Swift.String
  public static func decryptPEM(_ pemKey: Swift.String, passphrase: Swift.String) throws -> Swift.String
  @objc deinit
}
extension cryptography.CCError : Swift.Equatable {}
extension cryptography.CCError : Swift.Hashable {}
extension cryptography.CCError : Swift.RawRepresentable {}
extension cryptography.TransactionResultStatus : Swift.Equatable {}
extension cryptography.TransactionResultStatus : Swift.Hashable {}
extension cryptography.TransactionResultStatus : Swift.RawRepresentable {}
extension cryptography.HTTPStatusCodeHovita : Swift.Equatable {}
extension cryptography.HTTPStatusCodeHovita : Swift.Hashable {}
extension cryptography.HTTPStatusCodeHovita : Swift.RawRepresentable {}
extension cryptography.BlockMode : Swift.Equatable {}
extension cryptography.BlockMode : Swift.Hashable {}
extension cryptography.BlockMode : Swift.RawRepresentable {}
extension cryptography.CryptoSwiftCTR : cryptography.CryptoSwiftBlockMode {}
extension cryptography.CryptoSwiftCTR.Error : Swift.Equatable {}
extension cryptography.CryptoSwiftCTR.Error : Swift.Hashable {}
extension cryptography.IssueCertStepResultModel : Swift.Equatable {}
extension cryptography.IssueCertStepResultModel : Swift.Hashable {}
extension cryptography.IssueCertStepResultModel : Swift.RawRepresentable {}
extension cryptography.FoundationTransportError : Swift.Equatable {}
extension cryptography.FoundationTransportError : Swift.Hashable {}
extension cryptography.CryptoSwiftPKCS5.CryptoSwiftPBKDF1.Error : Swift.Equatable {}
extension cryptography.CryptoSwiftPKCS5.CryptoSwiftPBKDF1.Error : Swift.Hashable {}
extension cryptography.CryptoSwiftPKCS5.CryptoSwiftPBKDF1.Variant : Swift.Equatable {}
extension cryptography.CryptoSwiftPKCS5.CryptoSwiftPBKDF1.Variant : Swift.Hashable {}
extension cryptography.CryptoSwiftSHA2.Variant : Swift.Equatable {}
extension cryptography.CryptoSwiftSHA2.Variant : Swift.Hashable {}
extension cryptography.CryptoSwiftSHA2.Variant : Swift.Sendable {}
extension cryptography.HTTPModelShortType : Swift.Equatable {}
extension cryptography.HTTPModelShortType : Swift.Hashable {}
extension cryptography.HTTPModelShortType : Swift.RawRepresentable {}
extension cryptography.LaodingIndicatorType : Swift.Equatable {}
extension cryptography.LaodingIndicatorType : Swift.Hashable {}
extension cryptography.PEMEncryptedPrivateKey.EncMode : Swift.Equatable {}
extension cryptography.PEMEncryptedPrivateKey.EncMode : Swift.Hashable {}
extension cryptography.TransactionTypeString : Swift.Equatable {}
extension cryptography.TransactionTypeString : Swift.Hashable {}
extension cryptography.TransactionTypeString : Swift.RawRepresentable {}
extension cryptography.KeyTypeEnum : Swift.Equatable {}
extension cryptography.KeyTypeEnum : Swift.Hashable {}
extension cryptography.KeyTypeEnum : Swift.RawRepresentable {}
extension cryptography.AppStrings.Splash : Swift.Equatable {}
extension cryptography.AppStrings.Splash : Swift.Hashable {}
extension cryptography.AppStrings.Splash : Swift.RawRepresentable {}
extension cryptography.AppStrings.ConfirmSign : Swift.Equatable {}
extension cryptography.AppStrings.ConfirmSign : Swift.Hashable {}
extension cryptography.AppStrings.ConfirmSign : Swift.RawRepresentable {}
extension cryptography.AppStrings.Register : Swift.Equatable {}
extension cryptography.AppStrings.Register : Swift.Hashable {}
extension cryptography.AppStrings.Register : Swift.RawRepresentable {}
extension cryptography.AppStrings.Login : Swift.Equatable {}
extension cryptography.AppStrings.Login : Swift.Hashable {}
extension cryptography.AppStrings.Login : Swift.RawRepresentable {}
extension cryptography.AppStrings.CertDetials : Swift.Equatable {}
extension cryptography.AppStrings.CertDetials : Swift.Hashable {}
extension cryptography.AppStrings.CertDetials : Swift.RawRepresentable {}
extension cryptography.AppStrings.CertList : Swift.Equatable {}
extension cryptography.AppStrings.CertList : Swift.Hashable {}
extension cryptography.AppStrings.CertList : Swift.RawRepresentable {}
extension cryptography.AppStrings.CertsAPI : Swift.Equatable {}
extension cryptography.AppStrings.CertsAPI : Swift.Hashable {}
extension cryptography.AppStrings.CertsAPI : Swift.RawRepresentable {}
extension cryptography.AppStrings.BranchOffice : Swift.Equatable {}
extension cryptography.AppStrings.BranchOffice : Swift.Hashable {}
extension cryptography.AppStrings.BranchOffice : Swift.RawRepresentable {}
extension cryptography.AppStrings.BranchOfficeDetails : Swift.Equatable {}
extension cryptography.AppStrings.BranchOfficeDetails : Swift.Hashable {}
extension cryptography.AppStrings.BranchOfficeDetails : Swift.RawRepresentable {}
extension cryptography.AppStrings.Home : Swift.Equatable {}
extension cryptography.AppStrings.Home : Swift.Hashable {}
extension cryptography.AppStrings.Home : Swift.RawRepresentable {}
extension cryptography.AppStrings.Profile : Swift.Equatable {}
extension cryptography.AppStrings.Profile : Swift.Hashable {}
extension cryptography.AppStrings.Profile : Swift.RawRepresentable {}
extension cryptography.AppStrings.ChangePassword : Swift.Equatable {}
extension cryptography.AppStrings.ChangePassword : Swift.Hashable {}
extension cryptography.AppStrings.ChangePassword : Swift.RawRepresentable {}
extension cryptography.AppStrings.Dashboard : Swift.Equatable {}
extension cryptography.AppStrings.Dashboard : Swift.Hashable {}
extension cryptography.AppStrings.Dashboard : Swift.RawRepresentable {}
extension cryptography.AppStrings.TransactionHistory : Swift.Equatable {}
extension cryptography.AppStrings.TransactionHistory : Swift.Hashable {}
extension cryptography.AppStrings.TransactionHistory : Swift.RawRepresentable {}
extension cryptography.AppStrings.TransactionHistoryDetails : Swift.Equatable {}
extension cryptography.AppStrings.TransactionHistoryDetails : Swift.Hashable {}
extension cryptography.AppStrings.TransactionHistoryDetails : Swift.RawRepresentable {}
extension cryptography.AppStrings.Payment : Swift.Equatable {}
extension cryptography.AppStrings.Payment : Swift.Hashable {}
extension cryptography.AppStrings.Payment : Swift.RawRepresentable {}
extension cryptography.AppStrings.AddUserInformation : Swift.Equatable {}
extension cryptography.AppStrings.AddUserInformation : Swift.Hashable {}
extension cryptography.AppStrings.AddUserInformation : Swift.RawRepresentable {}
extension cryptography.AppStrings.Ekyc : Swift.Equatable {}
extension cryptography.AppStrings.Ekyc : Swift.Hashable {}
extension cryptography.AppStrings.Ekyc : Swift.RawRepresentable {}
extension cryptography.AppStrings.IssueCertTypeOption : Swift.Equatable {}
extension cryptography.AppStrings.IssueCertTypeOption : Swift.Hashable {}
extension cryptography.AppStrings.IssueCertTypeOption : Swift.RawRepresentable {}
extension cryptography.AppStrings.IssueCertStepsResult : Swift.Equatable {}
extension cryptography.AppStrings.IssueCertStepsResult : Swift.Hashable {}
extension cryptography.AppStrings.IssueCertStepsResult : Swift.RawRepresentable {}
extension cryptography.AppStrings.ResultSuccess : Swift.Equatable {}
extension cryptography.AppStrings.ResultSuccess : Swift.Hashable {}
extension cryptography.AppStrings.ResultSuccess : Swift.RawRepresentable {}
extension cryptography.AppStrings.Setting : Swift.Equatable {}
extension cryptography.AppStrings.Setting : Swift.Hashable {}
extension cryptography.AppStrings.Setting : Swift.RawRepresentable {}
extension cryptography.AppStrings.ExitSdkString : Swift.Equatable {}
extension cryptography.AppStrings.ExitSdkString : Swift.Hashable {}
extension cryptography.AppStrings.ExitSdkString : Swift.RawRepresentable {}
extension cryptography.AppStrings.DeleteAccount : Swift.Equatable {}
extension cryptography.AppStrings.DeleteAccount : Swift.Hashable {}
extension cryptography.AppStrings.DeleteAccount : Swift.RawRepresentable {}
extension cryptography.AppStrings.ViewPdfFileInsertSignature : Swift.Equatable {}
extension cryptography.AppStrings.ViewPdfFileInsertSignature : Swift.Hashable {}
extension cryptography.AppStrings.ViewPdfFileInsertSignature : Swift.RawRepresentable {}
extension cryptography.AppStrings.ErrorAlert : Swift.Equatable {}
extension cryptography.AppStrings.ErrorAlert : Swift.Hashable {}
extension cryptography.AppStrings.ErrorAlert : Swift.RawRepresentable {}
extension cryptography.AppStrings.ArchiveRequests : Swift.Equatable {}
extension cryptography.AppStrings.ArchiveRequests : Swift.Hashable {}
extension cryptography.AppStrings.ArchiveRequests : Swift.RawRepresentable {}
extension cryptography.AppStrings.BranchOffic : Swift.Equatable {}
extension cryptography.AppStrings.BranchOffic : Swift.Hashable {}
extension cryptography.AppStrings.BranchOffic : Swift.RawRepresentable {}
extension cryptography.AppStrings.Authenticat : Swift.Equatable {}
extension cryptography.AppStrings.Authenticat : Swift.Hashable {}
extension cryptography.AppStrings.Authenticat : Swift.RawRepresentable {}
extension cryptography.AppStrings.Cert : Swift.Equatable {}
extension cryptography.AppStrings.Cert : Swift.Hashable {}
extension cryptography.AppStrings.Cert : Swift.RawRepresentable {}
extension cryptography.AppStrings.ResetPin : Swift.Equatable {}
extension cryptography.AppStrings.ResetPin : Swift.Hashable {}
extension cryptography.AppStrings.ResetPin : Swift.RawRepresentable {}
extension cryptography.AppStrings.ErrorMessage : Swift.Equatable {}
extension cryptography.AppStrings.ErrorMessage : Swift.Hashable {}
extension cryptography.AppStrings.ErrorMessage : Swift.RawRepresentable {}
extension cryptography.LogType : Swift.Equatable {}
extension cryptography.LogType : Swift.Hashable {}
extension cryptography.FoundationSecurityError : Swift.Equatable {}
extension cryptography.FoundationSecurityError : Swift.Hashable {}
extension cryptography.SecurityErrorCode : Swift.Equatable {}
extension cryptography.SecurityErrorCode : Swift.Hashable {}
extension cryptography.SecurityErrorCode : Swift.RawRepresentable {}
extension cryptography.KeyStoreEditorError : Swift.Equatable {}
extension cryptography.KeyStoreEditorError : Swift.Hashable {}
extension cryptography.KeyStoreEditorError : Swift.RawRepresentable {}
extension cryptography.CryptoSwiftOCB.Mode : Swift.Equatable {}
extension cryptography.CryptoSwiftOCB.Mode : Swift.Hashable {}
extension cryptography.CryptoSwiftOCB.Error : Swift.Equatable {}
extension cryptography.CryptoSwiftOCB.Error : Swift.Hashable {}
extension cryptography.KeyConvertError : Swift.Equatable {}
extension cryptography.KeyConvertError : Swift.Hashable {}
extension cryptography.CryptoSwiftBit : Swift.Equatable {}
extension cryptography.CryptoSwiftBit : Swift.Hashable {}
extension cryptography.CryptoSwiftBit : Swift.RawRepresentable {}
extension cryptography.CryptoSwiftPoly1305.CryptoSwiftError : Swift.Equatable {}
extension cryptography.CryptoSwiftPoly1305.CryptoSwiftError : Swift.Hashable {}
extension cryptography.CryptoSwiftAES.Error : Swift.Equatable {}
extension cryptography.CryptoSwiftAES.Error : Swift.Hashable {}
extension cryptography.CryptoSwiftAES.Variant : Swift.Equatable {}
extension cryptography.CryptoSwiftAES.Variant : Swift.Hashable {}
extension cryptography.CryptoSwiftAES.Variant : Swift.RawRepresentable {}
extension cryptography.MultipartForm.MultipartType : Swift.Equatable {}
extension cryptography.MultipartForm.MultipartType : Swift.Hashable {}
extension cryptography.MultipartForm.MultipartType : Swift.RawRepresentable {}
extension cryptography.ErrorType : Swift.Equatable {}
extension cryptography.ErrorType : Swift.Hashable {}
extension cryptography.SignMechanismEnum : Swift.Equatable {}
extension cryptography.SignMechanismEnum : Swift.Hashable {}
extension cryptography.SignMechanismEnum : Swift.RawRepresentable {}
extension cryptography.DHParam : Swift.Equatable {}
extension cryptography.DHParam : Swift.Hashable {}
extension cryptography.CryptoSwiftCMAC.Error : Swift.Equatable {}
extension cryptography.CryptoSwiftCMAC.Error : Swift.Hashable {}
extension cryptography.SignModeEnum : Swift.Equatable {}
extension cryptography.SignModeEnum : Swift.Hashable {}
extension cryptography.SignModeEnum : Swift.RawRepresentable {}
extension cryptography.RegistrationBySignedMsisdnTypeView : Swift.Equatable {}
extension cryptography.RegistrationBySignedMsisdnTypeView : Swift.Hashable {}
extension cryptography.OID : Swift.Equatable {}
extension cryptography.OID : Swift.Hashable {}
extension cryptography.OID : Swift.RawRepresentable {}
extension cryptography.CryptoSwiftPCBC.Error : Swift.Equatable {}
extension cryptography.CryptoSwiftPCBC.Error : Swift.Hashable {}
extension cryptography.CertificateStatus : Swift.Equatable {}
extension cryptography.CertificateStatus : Swift.Hashable {}
extension cryptography.CertificateStatus : Swift.RawRepresentable {}
extension cryptography.PasswordPolicyType : Swift.Equatable {}
extension cryptography.PasswordPolicyType : Swift.Hashable {}
extension cryptography.PasswordPolicyType : Swift.RawRepresentable {}
extension cryptography.MessageTypeEnum : Swift.Equatable {}
extension cryptography.MessageTypeEnum : Swift.Hashable {}
extension cryptography.MessageTypeEnum : Swift.RawRepresentable {}
extension cryptography.CryptoSwiftHKDF.Error : Swift.Equatable {}
extension cryptography.CryptoSwiftHKDF.Error : Swift.Hashable {}
extension cryptography.CryptoSwiftPKCS5.PBKDF2.Error : Swift.Equatable {}
extension cryptography.CryptoSwiftPKCS5.PBKDF2.Error : Swift.Hashable {}
extension cryptography.RegisterType : Swift.Equatable {}
extension cryptography.RegisterType : Swift.Hashable {}
extension cryptography.HMACAlg : Swift.Equatable {}
extension cryptography.HMACAlg : Swift.Hashable {}
extension cryptography.HMACAlg : Swift.RawRepresentable {}
extension cryptography.PopUpTypeView : Swift.Equatable {}
extension cryptography.PopUpTypeView : Swift.Hashable {}
extension cryptography.OpMode : Swift.Equatable {}
extension cryptography.OpMode : Swift.Hashable {}
extension cryptography.OpMode : Swift.RawRepresentable {}
extension cryptography.TCPTransportError : Swift.Equatable {}
extension cryptography.TCPTransportError : Swift.Hashable {}
extension cryptography.CipherError : Swift.Equatable {}
extension cryptography.CipherError : Swift.Hashable {}
extension cryptography.CRC.Mode : Swift.Equatable {}
extension cryptography.CRC.Mode : Swift.Hashable {}
extension cryptography.CRC.Mode : Swift.RawRepresentable {}
extension cryptography.IssueCertParentType : Swift.Equatable {}
extension cryptography.IssueCertParentType : Swift.Hashable {}
extension cryptography.Padding : Swift.Equatable {}
extension cryptography.Padding : Swift.Hashable {}
extension cryptography.Padding : Swift.RawRepresentable {}
extension cryptography.CustomAlertControllerShadowStyle : Swift.Equatable {}
extension cryptography.CustomAlertControllerShadowStyle : Swift.Hashable {}
extension cryptography.Algorithm : Swift.Equatable {}
extension cryptography.Algorithm : Swift.Hashable {}
extension cryptography.Algorithm : Swift.RawRepresentable {}
extension cryptography.IssueCertTransactionStatus : Swift.Equatable {}
extension cryptography.IssueCertTransactionStatus : Swift.Hashable {}
extension cryptography.IssueCertTransactionStatus : Swift.RawRepresentable {}
extension cryptography.NFX.ENFXGesture : Swift.Equatable {}
extension cryptography.NFX.ENFXGesture : Swift.Hashable {}
extension cryptography.NFX.ENFXGesture : Swift.RawRepresentable {}
extension cryptography.AuthBlockMode : Swift.Equatable {}
extension cryptography.AuthBlockMode : Swift.Hashable {}
extension cryptography.AuthBlockMode : Swift.RawRepresentable {}
extension cryptography.CryptoSwiftCCM : cryptography.CryptoSwiftBlockMode {}
extension cryptography.CryptoSwiftCCM.Error : Swift.Equatable {}
extension cryptography.CryptoSwiftCCM.Error : Swift.Hashable {}
extension cryptography.PersianDatePickerStyle : Swift.Equatable {}
extension cryptography.PersianDatePickerStyle : Swift.Hashable {}
extension cryptography.CryptoSwiftCFB.Error : Swift.Equatable {}
extension cryptography.CryptoSwiftCFB.Error : Swift.Hashable {}
extension cryptography.CryptoSwiftCFB.SegmentSize : Swift.Equatable {}
extension cryptography.CryptoSwiftCFB.SegmentSize : Swift.Hashable {}
extension cryptography.CryptoSwiftCFB.SegmentSize : Swift.RawRepresentable {}
extension cryptography.Blowfish.Error : Swift.Equatable {}
extension cryptography.Blowfish.Error : Swift.Hashable {}
extension cryptography.RSA.AsymmetricPadding : Swift.Equatable {}
extension cryptography.RSA.AsymmetricPadding : Swift.Hashable {}
extension cryptography.RSA.AsymmetricPadding : Swift.RawRepresentable {}
extension cryptography.RSA.AsymmetricSAPadding : Swift.Equatable {}
extension cryptography.RSA.AsymmetricSAPadding : Swift.Hashable {}
extension cryptography.RSA.AsymmetricSAPadding : Swift.RawRepresentable {}
extension cryptography.RSA.KeyType : Swift.Equatable {}
extension cryptography.RSA.KeyType : Swift.Hashable {}
extension cryptography.RSA.KeyType : Swift.RawRepresentable {}
extension cryptography.CryptoSwiftGCM.Mode : Swift.Equatable {}
extension cryptography.CryptoSwiftGCM.Mode : Swift.Hashable {}
extension cryptography.CryptoSwiftGCM.Error : Swift.Equatable {}
extension cryptography.CryptoSwiftGCM.Error : Swift.Hashable {}
extension cryptography.CryptoSwiftRabbit.Error : Swift.Equatable {}
extension cryptography.CryptoSwiftRabbit.Error : Swift.Hashable {}
extension cryptography.DtbsContentTypeEnum : Swift.Equatable {}
extension cryptography.DtbsContentTypeEnum : Swift.Hashable {}
extension cryptography.DtbsContentTypeEnum : Swift.RawRepresentable {}
extension cryptography.DigestAlgorithm : Swift.Equatable {}
extension cryptography.DigestAlgorithm : Swift.Hashable {}
extension cryptography.DigestAlgorithm : Swift.RawRepresentable {}
extension Foundation.URLRequest.HTTPMethod : Swift.Equatable {}
extension Foundation.URLRequest.HTTPMethod : Swift.Hashable {}
extension Foundation.URLRequest.HTTPMethod : Swift.RawRepresentable {}
extension cryptography.ChaCha20.Error : Swift.Equatable {}
extension cryptography.ChaCha20.Error : Swift.Hashable {}
extension cryptography.ASN1Identifier.Class : Swift.Equatable {}
extension cryptography.ASN1Identifier.Class : Swift.Hashable {}
extension cryptography.ASN1Identifier.Class : Swift.RawRepresentable {}
extension cryptography.ASN1Identifier.TagNumber : Swift.Equatable {}
extension cryptography.ASN1Identifier.TagNumber : Swift.Hashable {}
extension cryptography.ASN1Identifier.TagNumber : Swift.RawRepresentable {}
extension cryptography.MsauLanguagesEnum : Swift.Equatable {}
extension cryptography.MsauLanguagesEnum : Swift.Hashable {}
extension cryptography.MsauLanguagesEnum : Swift.RawRepresentable {}
extension cryptography.LoginType : Swift.Equatable {}
extension cryptography.LoginType : Swift.Hashable {}
extension cryptography.DisplayMessageContentTypeEnum : Swift.Equatable {}
extension cryptography.DisplayMessageContentTypeEnum : Swift.Hashable {}
extension cryptography.DisplayMessageContentTypeEnum : Swift.RawRepresentable {}
extension cryptography.CryptoSwiftHMAC.Error : Swift.Equatable {}
extension cryptography.CryptoSwiftHMAC.Error : Swift.Hashable {}
extension cryptography.VideoQuality : Swift.Equatable {}
extension cryptography.VideoQuality : Swift.Hashable {}
extension cryptography.CloseCode : Swift.Equatable {}
extension cryptography.CloseCode : Swift.Hashable {}
extension cryptography.CloseCode : Swift.RawRepresentable {}
extension cryptography.FrameOpCode : Swift.Equatable {}
extension cryptography.FrameOpCode : Swift.Hashable {}
extension cryptography.FrameOpCode : Swift.RawRepresentable {}
extension cryptography.ErrorCodeHovita.ClinetGereated : Swift.Equatable {}
extension cryptography.ErrorCodeHovita.ClinetGereated : Swift.Hashable {}
extension cryptography.ErrorCodeHovita.ClinetGereated : Swift.RawRepresentable {}
extension cryptography.ErrorCodeHovita.Auth : Swift.Equatable {}
extension cryptography.ErrorCodeHovita.Auth : Swift.Hashable {}
extension cryptography.ErrorCodeHovita.Auth : Swift.RawRepresentable {}
extension cryptography.ErrorCodeHovita.DISPATCHER : Swift.Equatable {}
extension cryptography.ErrorCodeHovita.DISPATCHER : Swift.Hashable {}
extension cryptography.ErrorCodeHovita.DISPATCHER : Swift.RawRepresentable {}
extension cryptography.ErrorCodeHovita.RA : Swift.Equatable {}
extension cryptography.ErrorCodeHovita.RA : Swift.Hashable {}
extension cryptography.ErrorCodeHovita.RA : Swift.RawRepresentable {}
extension cryptography.CryptoSwiftSHA3.Variant : Swift.Equatable {}
extension cryptography.CryptoSwiftSHA3.Variant : Swift.Hashable {}
extension cryptography.TouchState : Swift.Equatable {}
extension cryptography.TouchState : Swift.Hashable {}
extension cryptography.CryptoSwiftCBC.Error : Swift.Equatable {}
extension cryptography.CryptoSwiftCBC.Error : Swift.Hashable {}
extension cryptography.CryptoSwiftOFB.Error : Swift.Equatable {}
extension cryptography.CryptoSwiftOFB.Error : Swift.Hashable {}
extension cryptography.Model : Swift.Equatable {}
extension cryptography.Model : Swift.Hashable {}
extension cryptography.Model : Swift.RawRepresentable {}
extension cryptography.SocketCertificatePinningError : Swift.Hashable {}
extension cryptography.CryptoSwiftPadding : Swift.Equatable {}
extension cryptography.CryptoSwiftPadding : Swift.Hashable {}
extension cryptography.KeyDerivation.PRFAlg : Swift.Equatable {}
extension cryptography.KeyDerivation.PRFAlg : Swift.Hashable {}
extension cryptography.KeyDerivation.PRFAlg : Swift.RawRepresentable {}
